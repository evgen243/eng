[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Посты",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nСоздание фотоальбома\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nimagemagick\n\n\n\n\n\n\n\n\n\nJun 23, 2025\n\n\n\n\n\n\n\n\n\n\n\n\ncopy/paste from/to vim\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nvim\n\n\n\n\n\n\n\n\n\nJun 23, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nОсновные опции ImageMagick для сжатия и ресайза\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nimagemagick\n\n\n\n\n\n\n\n\n\nJun 23, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nДобавление рамки, черно-белое и негатив, серое, PDF-альбом\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nimagemagick\n\n\n\n\n\n\n\n\n\nJun 23, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nvim copy/paste\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nvim\n\n\n\n\n\n\n\n\n\nJun 23, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nImageMagick - утилиты входящие в состав\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nimagemagick\n\n\n\n\n\n\n\n\n\nJun 23, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nImageMagick.Обработка изображений.\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nimagemagick\n\n\n\n\n\n\n\n\n\nJun 22, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nИзвлечение аудио из видео\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nffmpeg\n\n\n\n\n\n\n\n\n\nJun 22, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nImageMagick.Обработка изображений.\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nimagemagick\n\n\n\n\n\n\n\n\n\nJun 22, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nImageMagick. New!!!\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nimagemagick\n\n\n\n\n\n\n\n\n\nJun 22, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nКонвертировать медиа файлы между форматами\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nffmpeg\n\n\n\n\n\n\n\n\n\nJun 21, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nvim keyboard shortcuts\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nvim\n\n\n\n\n\n\n\n\n\nJun 21, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nvi keyboard shortcuts\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\neditor\n\n\nvim\n\n\n\n\n\n\n\n\n\nJun 21, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nНарезка кадров\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nffmpeg\n\n\n\n\n\n\n\n\n\nJun 21, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nСклейка медиа-файлов\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nffmpeg\n\n\n\n\n\n\n\n\n\nJun 20, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nvimcommander - FM\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nvim\n\n\n\n\n\n\n\n\n\nJun 20, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nКонвертировать mp3 в ogg_vorbis\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nffmpeg\n\n\n\n\n\n\n\n\n\nJun 19, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nИзвлечение аудио из видео(один файл)\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nffmpeg\n\n\n\n\n\n\n\n\n\nJun 19, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nИзвлечь звук из всех видео в папке\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nffmpeg\n\n\n\n\n\n\n\n\n\nJun 19, 2025\n\n\n\n\n\n\n\n\n\n\n\n\npandoc-конвертирование файлов\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nconvert\n\n\n\n\n\n\n\n\n\nJun 18, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nless\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\neditor\n\n\n\n\n\n\n\n\n\nJun 18, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nmore\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\neditor\n\n\n\n\n\n\n\n\n\nJun 18, 2025\n\n\n\n\n\n\n\n\n\n\n\n\npoppler-конвертирование PDF в изображения\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nconvert\n\n\n\n\n\n\n\n\n\nJun 18, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nalien - преобразования форматов между пакетами\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nsystem\n\n\n\n\n\n\n\n\n\nJun 18, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nWayland vs X11\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nwayland/X11\n\n\n\n\n\n\n\n\n\nJun 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nVim\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\neditor\n\n\nvim\n\n\n\n\n\n\n\n\n\nJun 4, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nsudo\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nsystem\n\n\n\n\n\n\n\n\n\nApr 25, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nCurl.Консольный менеджер загрузок.\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\ninternet\n\n\n\n\n\n\n\n\n\nApr 24, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nСоздание/Удаление пользователя\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nsystem\n\n\n\n\n\n\n\n\n\nApr 24, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nСоздание файловой системы\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nsystem\n\n\n\n\n\n\n\n\n\nApr 23, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nBat\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\neditor\n\n\n\n\n\n\n\n\n\nApr 23, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nТерминал\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nsystem\n\n\n\n\n\n\n\n\n\nApr 11, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nФайловый менеджер\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nsystem\n\n\n\n\n\n\n\n\n\nApr 10, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nFsck - проверка флешки на ошибки\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nsystem\n\n\n\n\n\n\n\n\n\nApr 10, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nMpg123\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nmusic\n\n\n\n\n\n\n\n\n\nApr 10, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nNano - консольный,текстовой редактор\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\neditor\n\n\n\n\n\n\n\n\n\nApr 9, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nCat\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\neditor\n\n\n\n\n\n\n\n\n\nApr 9, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nMount - монтирование дисков,образов\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\ndisk\n\n\nsystem\n\n\n\n\n\n\n\n\n\nApr 9, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nАрхиваторы в консоли\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\narchivers\n\n\n\n\n\n\n\n\n\nApr 9, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nMoc/mocp - консольный аудио проигрыватель.\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nmusic\n\n\n\n\n\n\n\n\n\nApr 9, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ncron - Планировщик заданий.Консольный.\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nsystem\n\n\n\n\n\n\n\n\n\nApr 8, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nWget.Консольный менеджер загрузок.\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\ninternet\n\n\n\n\n\n\n\n\n\nApr 8, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nКоманда rsync(резервное копирование)\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\ncopy\n\n\n\n\n\n\n\n\n\nApr 7, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ndd - Запись iso-образа\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\ndisk\n\n\n\n\n\n\n\n\n\nApr 6, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nКоманда inxi(данные о системе)\n\n\n\n\n\n\nnews\n\n\nterminal\n\n\nsystem\n\n\n\n\n\n\n\n\n\nApr 6, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nКоманда lsblk\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nterminal\n\n\ndisk\n\n\n\n\n\n\n\n\n\nApr 6, 2024\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/archivers/index.html",
    "href": "posts/archivers/index.html",
    "title": "Архиваторы в консоли",
    "section": "",
    "text": "Иногда бывают ситуации когда нужно использовать архиватор в консоли.В некоторых случаях это быстрее и удобнее.\n\nАрхив TAR\n\nАрхивирование файла или директории без сжатия:\ntar -cf архив.tar файл\n\nдополнительный ключ “v”, для подробного вывода процесса архивации:\n\n\ntar -cvf архив.tar директория/\n\n\n\nРаспаковка архива tar:\n\ntar -xvf архив.tar\n\n\n\nАрхивирование с использованием сжатия gzip:\n\ntar -zcvf архив.tar.gz файл\ntar -zcvf архив.tar.gz директория/\n\n\n\nАрхивирование с использованием сжатия bzip2:\n\ntar -jcvf архив.tar.bz2 файл\ntar -jcvf архив.tar.bz2 директория/\n\n\n\nПроверка архива gzip без распаковки:\n\ntar -zvtf архив.tar.gz\n\n\n\nПроверка архива bzip2 без распаковки:\n\ntar -jvtf архив.tar.bz2\n\n\n\nРаспаковка архива gzip:\n\ntar -zxvf архив.tar.gz\n\n\n\nРаспаковка архива bzip2 с указанием конечной папки для файлов:\n\ntar -jxvf архив.tar.bz2 директория/\n\n\n\nКоманды Tar:\n\nx — извлечь файлы из архива;\nv — подробный вывод информации на экран;\nf — Обязательная опция. Если не указать, Tar будет пытаться использовать магнитную ленту вместо файла;\nz — обработать архив сжатый gzip’ом;\nj — обработать архив сжатый bzip’ом.\n\n\n\n\nАрхив ZIP\n\nАрхивирование файла:\n\nzip архив.zip файл\n\n\n\nАрхивирование директории:\n\nzip -r архив.zip директория/\n\n\n\nПовышение уровня сжатия:\n\nzip -0 архив.zip файл\nzip -9 архив.zip файл\n\n\n\nЗащита архива паролем не рекомендуемая опция, показывает пароль:\nzip -P пароль архив.zip файл\n\n\nЗащита архива паролем,безопасная опция, пароль запрашивается и скрывается при вводе:\n\nzip -e архив.zip файл\n\n\n\nРазархивирование:\n\nunzip архив.zip\n\n\n\nДетальный вывод информации при распаковке:\n\nunzip -v архив.zip\n\n\n\nПолучение списка содержимого архива:\n\nunzip -l архив.zip\n\n\n\n\nАрхив 7z\n\nУстанавливаем:(В некоторых дистрибутивах установлен)\n\nsudo apt install p7zip p7zip-full (или Вашим пакетным менеджером)\n\n\n\nАрхивируем:\n\n7z a arch.7z file01.foo file02.foo\n\n\n\nРаспаковка:\n\n7z x arch.7z\n7z x arch.7z -o/куда_извлекать\n\n\n\nПросмотр архива:\n\n7z l arch.7z\n7z l -slt arch.7z\n\n\n\n\nAtool\n\nЕсли использовать утилиту atool, то вы сможете работать с любым форматом архивов\n\n\nУстановка:\n\nsudo apt install atool (или Вашим пакетным менеджером)\n\n\n\nРаспаковка:\n\naunpack foobar.tar.gz\n\n\n\nАрхивирование:\n\napack myarchive.zip file1 file2"
  },
  {
    "objectID": "posts/bat/index.html",
    "href": "posts/bat/index.html",
    "title": "Bat",
    "section": "",
    "text": "bat — это продвинутый cat\nbat — это продвинутый клон cat с поддержкой подсветки синтаксиса и интеграцией Git.\nЕсли вы хотите больше комфорта при просмотре файлов в терминале то стоит обратить внимание на bat.\nУтилита bat поддерживает подсветку синтаксиса для большого количества языков программирования. Вывод текста в читаемом виде и нумерация строк позволяем проще воспринимать код.\n\nПоддержка Git.\nВы будете видеть какие строки были добавлены либо изменены.\nВ Slackware уже установлена из “коробки”.\nВ остальных - своим пакетным менеджером."
  },
  {
    "objectID": "posts/cat/index.html",
    "href": "posts/cat/index.html",
    "title": "Cat",
    "section": "",
    "text": "Команда cat - это одна из часто используемых команд Linux.\nС помощью этой команды можно очень просто посмотреть содержимое небольшого файла, склеить несколько файлов и многое другое.\n\nКоманда cat\nНазвание команды - это сокращения от слова catenate. По сути, задача команды cat очень проста - она читает данные из файла или стандартного ввода и выводит их на экран. Это все, чем занимается утилита.\nОпции позволяют очень сильно видоизменить вывод и сделать именно то, что вам нужно. Рассмотрим основные опции:\n\n$ cat опции файл1 файл2 …\n-b - нумеровать только непустые строки\n-E - показывать символ $ в конце каждой строки\n-n - нумеровать все строки\n-s - удалять пустые повторяющиеся строки\n-T - отображать табуляции в виде ^I\n-h - отобразить справку\n-v - версия утилиты\n\nЭто было все описание linux cat, которое вам следует знать, далее рассмотрим примеры cat linux. Использование cat в Linux\nСамое простое, где используется команда cat - это просмотр содержимого файла:\n\n$ cat file\n\nКоманда просто выведет все, что есть в файле. Чтобы вывести несколько файлов достаточно просто передать их в параметрах:\n\n$ cat file file1\n\nвы можете нумеровать все строки в файле:\n\n$ cat -n file\n\nВозможность объединения нескольких файлов не была бы настолько полезна, если бы нельзя было записать все в один:\n\n$ cat file1 file2 &gt; file3\n$ cat file3\n\nМожно получить очень примитивный текстовый редактор - прочитаем ввод и перенаправим его вместо вывода на экран в файл:\n\n$ cat &gt; file2\nEnter\nbla-bla-bla\nEnter\nCtrl+D\n\nПосмотреть содержимое созданного файла:\n\n$ cat file2"
  },
  {
    "objectID": "posts/console/index.html",
    "href": "posts/console/index.html",
    "title": "Терминал",
    "section": "",
    "text": "Попробую здесь показать как обычный терминал может заменить файловый менеджер.\nБывают случаи когда проще воспользоваться терминалом как файловым менеджером.Никогда не встречались с ситуацией когда не возможно удалить файл,директорию?В консоли это не вопрос.\nРабота в терминале может показаться не комфортной,не удобной,нужно запоминать много команд.\nНа самом деле для начала работы нужно запомнить 10-12 команд.Ну а далее,если заинтересует,будет проще.\n\n\npwd - выводит полный путь директории где находимся\nls - выводит что находится в директории\nmkdir - создать пустую директорию\ncd - сменить директорию\ntouch file1 - создать пустой файл\n&gt; file1 - создать пустой файл\necho &gt; file.txt - создать пустой файл\necho ‘bla-bla-bla-bla’&gt;&gt; file.txt - дописать в файл\necho ‘bla-bla’&gt; file.txt - перезаписать(сотрет прежнее содержимое) в файл\ncat - просмотр файла\nmv - переименовать,переместить файл,директорию\ncp - копировать файл, пустую директорию\ncp -r - копировать директорию с файлами\nrm - удалить файл\nrmdir - удалить пустую директорию\nrm -r - удалить директорию с файлами\n\nС помощью оператора && (and) можно совмещать команды:\n\n$ mkdir new\n$ cd mkdir new/ && touch file.txt file.md"
  },
  {
    "objectID": "posts/cron/index.html",
    "href": "posts/cron/index.html",
    "title": "cron - Планировщик заданий.Консольный.",
    "section": "",
    "text": "Есть много полезных консольных команд и приложений.Одна из них Cron(crontab).\n#|  hour (0-23),\n#|  |   day of the month (1-31),\n#|  |   |   month of the year (1-12),\n#|  |   |   |   day of the week (0-6 with 0=Sunday).\n#|  |   |   |   |   commands\n\ncrontab -e – открывает конфигурационный файл\ncrontab -l – показывает список задач из конфигурационного файла (все, что было запланировано).\ncrontab -r – удаляет конфигурационный файл вместе со всеми запланированными задачами.\nсrontab -v – показывает, когда в последний раз открывался конфигурационный файл.\n\n\ncrontab -e создать задание(работает от имени пользователя,без sudo)\n\n\nCron.Его основная задача выполнять нужные процессы в нужное время.(Планировщик заданий)\n\nНа моем примере:\n\ncrontab -e\n00 09 16 * * echo ‘date’ &gt; /home/jenit/Desktop/date.txt\n\n\n\n\nВ Astra Linux так делать запись:\n\nsudo crontab -u jenit -e\n00 09 16 * * echo ‘date’ &gt; /home/jenit/Desktop/date.txt\n\n(Расшифровка: в ноль минут,в девять часов,шестнадцатого числа,каждый месяц отпралять сообщение со словом data на рабочий стол,в файл data.txt.)\n00 - минуты\n09 - часы\n16 - дата,(день месяца)\n* - месяц\n* - день недели\n\nМой crontab -e\n\n00 09 16 * * echo ‘date’ &gt; /home/jenit/‘Рабочий стол’/date.txt\n00 08 05 03 * echo ‘Birthday’ &gt; /home/jenit/‘Рабочий стол’/date-Sl.txt\n\nПосмотрите в свое файловом менеджере как у Вас пишется “Рабочий стол” или “Desktop”\n\n\n\nEnter - сохранить\n\n\n\nЕсли нужно по расписанию проиграть звуковой файл.\n\n00 08 * * * /usr/bin/mpg123 /home/jenit/Music/mahnem.mp3\n\nУ меня почему то корректно работает только с mpg123(консольный аудио проигрыватель)"
  },
  {
    "objectID": "posts/curl/index.html",
    "href": "posts/curl/index.html",
    "title": "Curl.Консольный менеджер загрузок.",
    "section": "",
    "text": "cURL — инструмент командной строки и библиотека для передачи данных с URL-адресов.\nКоманда поддерживает многие протоколы, включая HTTP, HTTPS, FTP, SCP и SFTP.\n\nСкачивание:\n\n$ curl -o название файла URL\n$ curl опции ссылка\n\n\n\nОсновные опции:\n-# - отображать простой прогресс-бар во время загрузки;\n-0 - использовать протокол http 1.0;\n-1 - использовать протокол шифрования tlsv1;\n-2 - использовать sslv2;\n-3 - использовать sslv3;\n-4 - использовать ipv4;\n-6 - использовать ipv6;\n-A - указать свой USER_AGENT;\n-b - сохранить Cookie в файл;\n-c - отправить Cookie на сервер из файла;\n-C - продолжить загрузку файла с места разрыва или указанного смещения;\n-m - максимальное время ожидания ответа от сервера;\n-d - отправить данные методом POST;\n-D - сохранить заголовки, возвращенные сервером в файл;\n-e - задать поле Referer-uri, указывает с какого сайта пришел пользователь;\n-E - использовать внешний сертификат SSL;\n-f - не выводить сообщения об ошибках;\n-F - отправить данные в виде формы;\n-G - если эта опция включена, то все данные, указанные в опции -d будут передаваться методом GET;\n-H - передать заголовки на сервер;\n-I - получать только HTTP заголовок, а все содержимое страницы игнорировать;\n-j - прочитать и отправить cookie из файла;\n-J - удалить заголовок из запроса;\n-L - принимать и обрабатывать перенаправления;\n-s - максимальное количество перенаправлений с помощью Location;\n-o - выводить контент страницы в файл;\n-O - сохранять контент в файл с именем страницы или файла на сервере;\n-p - использовать прокси;\n--proto - указать протокол, который нужно использовать;\n-R -  сохранять время последнего изменения удаленного файла;\n-s - выводить минимум информации об ошибках;\n-S - выводить сообщения об ошибках;\n-T - загрузить файл на сервер;\n-v - максимально подробный вывод;\n-y - минимальная скорость загрузки;\n-Y - максимальная скорость загрузки;\n-z - скачать файл, только если он был модифицирован позже указанного времени;\n-V - вывести версию."
  },
  {
    "objectID": "posts/dd/index.html",
    "href": "posts/dd/index.html",
    "title": "dd - Запись iso-образа",
    "section": "",
    "text": "Способ - dd\nОпределить имя flash-носителя, например, sd[x]:\n\n$ sudo fdisk -l\n\nor\n\n$ lsblk\n\nПерейдите в консоли в каталог с iso-образом:\n\n$ cd /путь/до/образа\n\n\n\nЗапись iso-образа:\n(это для Всех OS)\n\n$ dd if=***.iso of=/dev/sd[x] status=progress\n\nstatus=progress - показывает прогресс записи\n\n\nВАЖНО!\nВместо sd[x] укажите свое имя носителя.\nПри этом будут стерты все данные на USB накопителе и записаны новые!\n\n\nДля RedOS\nДля систем с UEFI и таблицей разделов GPT следует подготовить flash-носитель, выполнив список команд:\n\nparted -s /dev/sd[x] mklabel gpt\nparted -s –align=optimal /dev/sd[x] mkpart REDOS fat32 1MiB 100%\nparted -s /dev/sd[x] set 1 boot on\nmkfs.vfat -F 32 /dev/sd[x]\n\n\n\nЗапись iso-образа:\n\n$ dd if=***.iso of=/dev/sd[x] status=progress\n\nstatus=progress - показывает прогресс записи\nЕсли хотите видеть процесс создания флешки для этого нужно будет установить улучшенную версию dd, которая носит название dcfldd.\n\nsudo apt-get install dcfldd\n\nСотрудники лаборатории DoD Computer Forensics Laboratory (DCFL) внесли некоторые изменения в команду dd, тем самым улучшив ее и применяя в своих исследовательских работах. В итоге на свет появилась команда dcfldd, которая обеспечивает хеширование копируемых данных через некоторые промежутки времени для их аутентификации. Более того, dcfldd работает гораздо быстрее, чем dd.\nТеперь, если Вы хотите именно видеть прогресс копирования, либо создания образа, Вам нужно выполнить команду:\n\nsudo dcfldd if=/dev/sdc of=image.iso"
  },
  {
    "objectID": "posts/fsck/index.html",
    "href": "posts/fsck/index.html",
    "title": "Fsck - проверка флешки на ошибки",
    "section": "",
    "text": "Для проверки флешки на ошибки можно воспользоваться утилитой fsck (англ. “file system check”).\n\nДля этого нужно выполнить следующие шаги:\n\nПодключите флешку к компьютеру.\nОпределите точное название дискового устройства, которое присвоено флешке, с помощью команды sudo fdisk -l or lsblk.\nОбычно флешки имеют формат sdx, где x - буква, соответствующая устройству.\n\n\nВыполните команду:\n\nsudo fsck /dev/sdx\n\nзаменив sdx на название дискового устройства, присвоенное вашей флешке.\nЕсли в процессе проверки будут найдены ошибки, то fsck предложит исправить их.\n\n\nДля этого нужно ввести:\n\ny (yes)\nEnter\n\nОбратите внимание, что процесс проверки может занять длительное время в зависимости от объема флешки.\nТакже, перед запуском fsck важно убедиться, что флешка не смонтирована.\nЕсли флешка уже смонтирована в системе, то ее нужно размонтировать с помощью команды:\n\nsudo umount /dev/sdx.\n\n\nP.S. Я флешку не подключал.Просто продемонстрировал работу программы.\n\nP.S. Здесь флешка в разъеме,но не подключена.Ошибок нет."
  },
  {
    "objectID": "posts/inxi/index.html",
    "href": "posts/inxi/index.html",
    "title": "Команда inxi(данные о системе)",
    "section": "",
    "text": "Inxi предустановлен во многих дистрибутивах Linux. Если не установлен, выполните одну из команд в терминале:\nОснованных на deb-пакетах (Ubuntu, Linux Mint, Debian):\n\nsudo apt install inxi\n\nОснованных на rpm-пакетах Fedora, RosaFresh:\n\nsudo dnf install inxi\n\nОткройте терминал, введите и выполните команду:\n\ninxi\n\nAlt Linux:\n\nsudo apt-get install inxi\n\nПосле выполнения команды inxi без аргументов, в терминале выводится краткий перечень информации.\nДля более полного вывода информации о вашем компьютере используйте:\n\ninxi -F\n\nС inxi вы можете даже узнать текущую температуру погоды вашей местности командой:\n\ninxi –weather\n\nПолную справку по утилите inxi можно получить:\n\ninxi -h\n\nЯ использую:\n\ninxi -IPS"
  },
  {
    "objectID": "posts/lf/index.html",
    "href": "posts/lf/index.html",
    "title": "Файловый менеджер",
    "section": "",
    "text": "Практически во всех дистрибутивах Линукс есть Midnight Commander - консольный файловый менеджер (mc).Мне больше по душе LF - это минимализм,быстрота,настраиваемость.\nLF означает List File — это терминальный файловый менеджер для Linux, написанный на языке Go.\nЗдесь я не стал подключать превью видео,фото.Я считаю это лишним “наворотом”,отвлекает.Но у кого будет желание,на ютубе множество рецептов.Здесь же самое основное - просмотр,переименование,перемещение,создание,редактирование,удаление.Еще для меня решающим фактором стало - это использование vim-раскладки клавиатуры.Настройки собраны как говорится “с миру - по нитке”.\n\n\nКак установить LF в Linux\nПерейдите на страницу выпусков LF на github и загрузите последнюю и актуальную версию для вашей операционной системы.\nОн будет содержать один исполняемый файл, поэтому просто переместите его в нужный каталог.\nЗапустите приведенную ниже команду, чтобы загрузить последнюю доступную версию для вашей операционной системы:\n# wget https://github.com/gokcehan/lf/releases/download/r8/lf-linux-amd64.tar.gz\nИзвлеките tar-архив с помощью следующей команды:\n# tar xvf lf-linux-amd64.tar.gz\nКак я уже говорил ранее, просто переместите исполняемый файл в каталог вашего пути:\n# mv lf /usr/local/bin\nНаконец, запустите команду LF, чтобы использовать ее. Нажимать qдля выхода из команды LF:\n# lf\n\n\nИспользование команды LF\nПерейдите на следующую страницу для просмотра видеоуроков\nИспользуйте следующие клавиши для навигации по файлам и папкам в каталоге:\nk or UP Arrow:Чтобы двигаться вверх\n\nj or DOWN Arrow:Чтобы двигаться вниз\nИспользуйте следующие клавиши для перемещения по половине страницы:\nCtrl+u:Переместиться на полстраницы вверх\n\nCtrl+d:Переместить на полстраницы вниз\nИспользуйте следующие клавиши для перемещения всей страницы:\nCtrl+b or PgUp:Чтобы переместить всю страницу вверх\n\nCtrl+f or PgDn:Чтобы переместить всю страницу вниз\nИспользуйте следующие клавиши для перехода к началу и концу списка:\ngg or Home:Для перехода в начало списка\n\nG or End:Для перехода в конец списка\nИспользуйте следующие клавиши для переключения, инвертирования и снятия пометок с файлов в текущем каталоге:\nspace:Для переключения файлов в текущем каталоге\n\nv:Инвертирует выборки в текущем каталоге\n\nu:Чтобы снять отметки со всех вариантов\nИспользуйте следующие клавиши для копирования, вырезания, вставки и удаления файлов:\ny:Чтобы скопировать текущий файл или выделенные фрагменты\n\nd:Чтобы вырезать текущий файл или выделенные фрагменты\n\np:Вставить скопированные или вырезанные файлы в текущий каталог\n\nc:Очищает скопированные или вырезанные файлы\nИспользовать для чтения встроенных или пользовательских команд:\n:set hiddenВведите следующую пользовательскую команду для просмотра скрытых файлов\n\n:set sortby size; set info size Введите следующую пользовательскую команду, чтобы просмотреть файлы и размер каталога.\nИспользовать $ для запуска команды в оболочке:\n$ touch magi.txt Чтобы создать новый файл в текущем каталоге\n\n$ mv magi.txt 2g.txt Чтобы переименовать файл.\nИспользуйте следующие клавиши для выполнения поиска:\n/[Pattern]:Чтобы выполнить поиск\n\nn:Переход к следующему сопоставлению с образцом\n\np:Переход к предыдущему сопоставлению шаблонов\n\n?[Pattern]:Чтобы выполнить обратный поиск\nНажмите z клавишу, чтобы просмотреть сочетания клавиш по умолчанию, связанные с клавишей z (с префиксом z).\nza      set info size:time\n\nzh      set hidden!\n\nzn      set info\n\nzr      set reverse!\n\nzs      set info size\n\nzt      set info time\nНажмите s клавишу, чтобы просмотреть сочетания клавиш по умолчанию, связанные с клавишей s (с префиксом s).\nsn :{{ set sortby natural;  установить информацию;  }}\n\nss :{{ установить размер сортировки;  установить размер информации;  }}\n\nst :{{ установить время сортировки;  установить время получения информации;  }}\nДополнительные команды.\n%[Command]:Используйте это для запуска команды в оболочке при передаче ввода из пользовательского интерфейса и вывода в пользовательский интерфейс\n\n![Command]:Используйте это для запуска команды в оболочке, которая после этого ожидает нажатия клавиши\n\n&[Command]:Чтобы запустить команду в фоновом режиме\n\nh:Чтобы перейти в родительский каталог.\n\n\nКонфигурационный файл LF(создать в ручную директорию,сам файл)\n/home/jenit/.config/lf/lfrc\nset shell sh\nset shellopts '-eu'\nset ifs \"\\n\"\nset drawbox\nset scrolloff 10\nset incsearch\nset ignoredia\nset period 2\nset ratios 1:2:2\n# set icons true\n\n# Custom Functions\ncmd mkdir ${{\nprintf \"Directory Name: \"\nread ans\nmkdir $ans\n}}\n\ncmd mkfile ${{\nprintf \"File Name: \"\nread ans\n$EDITOR $ans\n}}\n\n# Archive bindings\ncmd unarchive ${{\ncase \"$f\" in\n    *.zip) unzip \"$f\" ;;\n    *.tar.gz) tar -xzvf \"$f\" ;;\n    *.tar.bz2) tar -xjvf \"$f\" ;;\n    *.tar) tar -xvf \"$f\" ;;\n    *) echo \"Unsupported format\" ;;\nesac\n}}\n\n# Trash bindings\ncmd trash ${{\nfiles=$(printf \"$fx\" | tr '\\n' ';')\nwhile [ \"$files\" ]; do\n    file=${files%%;*}\n\n    trash-put \"$(basename \"$file\")\"\n    if [ \"$files\" = \"$file\" ]; then\n    files=''\n    else\n    files=\"${files#*;}\"\n    fi\ndone\n}}\n\ncmd restore_trash ${{\ntrash-restore\n}}\n\n\n\nmap f ${{\n    selected=\"$(fzf)\"\n    [ -d \"$selected\" ] && cmd=cd || cmd=select\n    lf -remote \"send $id $cmd '$selected'\"\n}}\n\n\nmap D delete\nmap x extract # извлечь архив\n\ncmd extract ${{\n    set -f\n    case $f in\n        *.tar.bz|*.tar.bz2|*.tbz|*.tbz2) tar xjvf $f;;\n        *.tar.gz|*.tgz) tar xzvf $f;;\n        *.tar.xz|*.txz) tar xJvf $f;;\n        *.zip) unzip $f;;\n        *.rar) unrar x $f;;\n        *.7z) 7z x $f;;\n    esac\n}}\n\ncmd tar ${{\n    set -f\n    mkdir $1\n    cp -r $fx $1\n    tar czf $1.tar.gz $1\n    rm -rf $1\n}}\n\ncmd zip ${{\n    set -f\n    mkdir $1\n    cp -r $fx $1\n    zip -r $1.zip $1\n    rm -rf $1\n}}\n\n# Установленные клавиши(hotkey)\n# Bindings\nmap d\nmap m\n\n# запуск внешних программ\n# map c $vscodium \"$f\"\nmap gk $konsole \"$f\"\n# map ae $wine \"$f\"\n\nmap au unarchive\n\n\n# Basic Functions\nmap . set hidden!\nmap dd trash\nmap dr restore_trash\nmap p paste\nmap x cut\nmap y copy\nmap &lt;enter&gt; open\nmap R reload\nmap mf mkfile\nmap md mkdir\nmap bg setwallpaper\nmap C clear\n\n# Movement\nmap gD cd ~/Documents\nmap gd cd ~/Downloads\nmap gp cd ~/Pictures\nmap gc cd ~/.config\nmap gr cd ~/repos\nmap gv cd ~/Videos\nmap gs cd ~/.local/bin\nmap gt cd ~/.local/share/Trash/files"
  },
  {
    "objectID": "posts/lsblk/index.html",
    "href": "posts/lsblk/index.html",
    "title": "Команда lsblk",
    "section": "",
    "text": "Команда lsblk позволяет получить информацию о блочных устройствах,т.е о разделах - sda, sdb и sdc.\nМожно получить информацию об отдельном диске, если передавть его в качестве аргумента:\n\n$ lsblk /dev/sdb\n\nОпция -f или –fs позволяет добавить в вывод информацию о файловых системах."
  },
  {
    "objectID": "posts/mkfs/index.html",
    "href": "posts/mkfs/index.html",
    "title": "Создание файловой системы",
    "section": "",
    "text": "Буквы в mkfs значке означают «make file system» (создать файловую систему)\nСоздать файловую систему семейства ext,fat,ntfs на устройстве можно с помощью команды mkfs.\n\nЕе синтаксис выглядит следующим образом:\n\nsudo mkfs -t [fs type] [target device]\nsudo mkfs -t тип устройство\n\n\n\nВы также можете использовать команду mkfs следующим образом:\n\nmkfs.[fs type] [target device]\n\n\n\nДоступны дополнительные параметры:\n-с - проверить устройство на наличие битых секторов\n-b - размер блока файловой системы\n-j - использовать журналирование для ext3\n-L - задать метку раздела\n-v - показать подробную информацию о процессе работы\n-V - версия программы\n\n\nнаиболее распространенный тип файловых систем:\nFAT*\n\nNTFS\n\next*\n\n\nСоздаем файловую систему на нашем устройстве.\nна примере Linux:\nmkfs без опций создает файловую систему ext2\nЕсли вы не укажете тип файловой системы для целевого устройства, он будет использовать файловую систему ext2 по умолчанию.\n\nsudo mkfs /dev/sdb1\n\n\n\nУкажите тип файла с помощью mkfs\nИспользование ext2 не очень удобно или целесообразно.\nВ наши дни большинство систем Linux рекомендуют использовать ext4.\n\n\nВы можете указать файловую систему следующим образом:\n\nsudo mkfs -t ext4 /dev/sdb1\n\n\n\nВы также можете использовать это так:\n\nsudo mkfs.ext4 /dev/sdb1\n\n\n\nпроверить наличие плохих блоков на устройстве\nимейте в виду, что проверка часто занимает много времени\n\nsudo mkfs -c /dev/sdb1\n\n\n\nПроверьте вновь созданную файловую систему\nСначала проверьте файловую систему устройства, которое вы только что использовали.\n\nsudo file -sL /dev/sdb1"
  },
  {
    "objectID": "posts/moc/index.html",
    "href": "posts/moc/index.html",
    "title": "Moc/mocp - консольный аудио проигрыватель.",
    "section": "",
    "text": "Конфигурацию нашел в итернете,где не помню.Понравилась.\n\nmoc/mocp консольный проигрыватель\n\nРекомендую создать в директории ~/.moc файл конфигурации следующего содержания:\n\nnano ~/.moc/config\n\nMusicDir = “/home/user/Music” #Ваша папка с музыкой, в которую вы попадете нажав m\nRepeat = yes #Включает автоповтор автоматически при запуске плеера (без конфига он выключен)\nShuffle = no #Включает беспорядочное воспроизведение, можете включить, если хотите\nAutoNext = yes #Включает автоматический переход к следующему\nShowHiddenFiles = no #Скрытые файлы не отображаем, вряд ли там будет музыка\nStartInMusicDir = yes #Плеер будет открывать при запуске вашу папку с музыкой\nSavePlaylist = yes #Сохраняет плейлист после выхода из плеера\nTheme = transparent-background #То самое полупрозрачное, черное оформление, как на скрине. Остальные варианты лежат в /usr/share/moc\n\n\nЗапуск плеера:\n\nmocp\n\n\n\nУправление плеером тоже весьма простое:\n\na – (в обозревателе) - добавить файл или папку в плейлист Shift+A - добавить папку рекурсивно (со всеми подкаталогами и их содержимым)\nq – отправляет программу в фоновый режим (при этом музыка еще играет ака демон)\nQ – выйти из программы\ns – остановить воспроизведение\nn – следующий трек\nb – предыдущий\np – пауза\nS – шаффл\nR – повтор\nX – автоматический переход на следующий трек\nm – перейти в каталог музыки\nV – сохранить плейлист\n&lt; и &gt; – управление громкостью\nd - удалить композицию\nперемотка осуществляется стрелками (вправо/влево)\nTab - переключиться между обозревателем файлов и плейлистом ↑, ↓, PgUp/PgDn, Home/End - навигация по списку файлов/плейлисту\nEnter - в обозревателе файлов - войти в папку или начать воспроизведение выбранного файла (без изменения плейлиста) в плейлисте - переключиться на выбранный трек\nA (в обозревателе) - добавить файл или папку в плейлист Shift+A - добавить папку рекурсивно (со всеми подкаталогами и их содержимым)\nD (в плейлисте) - удалить файл из плейлиста\nShift+C - очистить плейлист\n\nЛично я считаю данный плеер весьма удобным для своих целей."
  },
  {
    "objectID": "posts/mount/index.html",
    "href": "posts/mount/index.html",
    "title": "Mount - монтирование дисков,образов",
    "section": "",
    "text": "Команда mount в линуксе является очень гибким инструментом. С помощью команды mount можно подключить сетевой диск, раздел жесткого диска или USB-накопитель.\nУстройства, которые в данный момент подключены к компьютеру, можно посмотреть набрав в консоли:\n\nsudo fdisk -l\n\nили\n\nlsblk.\n\n\nМонтирование ISO\nДля начала создаем точку монтирования — папку /mnt/iso\n(естественно, /mnt/iso/ — это папка, где будут лежать наши смонтированные образы (вдруг их будет несколько, так чтобы сразу видеть, где образы, а где все остальное):\n(Точку монтирования можно взять любую)\n# mkdir /mnt/iso\nЕсли это ISO, все очень просто. Монтируем так:\n\n# mount -o loop -t iso9660 file.iso /mnt/iso\n\nпараметр -o loop, который указывает, что используется файл *.iso\nПосле того, как ISO образ диска будет смонтирован, Вы получите следующее сообщение:\nmount: warning: /mnt/mount_point seems to be mounted read-only\nМожете спокойно его игнорировать, так как в соответствии со стандартом ISO 9660, ISO образы всегда монтируются только в режиме read-only (только чтение).\nВсе, теперь все файлы из образа появятся в этой самой точке монтирования (/mnt/iso).\nПроверяем что ISO файл смонтирован:\nВыведите список смонтированных устройств, чтобы убедиться что наш ISO образ успешно примонтировался:\n\n$ mount\n\nВнизу Вы должны увидеть строку на подобии следующей:\n\n/home/user/disk.iso on /mnt/mount_point type iso9660 (ro)\n\nТеперь Вы можете перейти в точку монтирования и просмотреть файлы содержащиеся на ISO образе диска:\n\n$ cd /mnt/mount_point\n$ ls -l\n\nТип файловой системы (iso9660) лучше, все-таки, указать, но можно и не указывать.\n\n# mount file.iso /mnt/iso\n\n\n\nРазмонтирование ISO файла в Linux\nИспользуйте следующую команду для размонтирования ISO образа диска:\n\n$ sudo umount /dev/sdXX\n\n\n\nМонтирование разделов жесткого диска\nПримонтируем раздел жесткого диска /dev/sdb1 к диску /dev/sda.\nТочку монтирования выберем, к примеру - /home/user/Видео.\nТочку монтирования можно взять любую:\n\nsudo mount /dev/sdb1 /home/user/Видео\n\nгде user — это название Вашего имени пользователя.\nсначала пишется команда mount, потом пишется то, что нужно присоединять (цифра показывает номер раздела, у нас он всего один), а потом куда присоединять.\n\n\nДиск монтируется в указанную папку.\nВ некоторых случаях, когда имеются логические ошибки на разделах подключаемого жесткого диска, нужно дополнительно указать тип файловой системы.\nВ данном случае у нас ext3.\n\nsudo mount -t ext3 /dev/sdb1 /home/user/Видео\n\nТак же этот параметр может принимать значения:\n\n-t ntfs или -t ntfs-3g\n-t vfat\n-t iso9660\n\nСоответственно для NTFS, FAT. Последний нужен только для подключения CD/DVD-ROM устройств и образа диска *.iso.\nПосмотреть полную информацию(доступный объем диска, свободное место) о примонтированных устройствах можно командой:\n\ndf -h\n\n\n\nОтмонтироватние устройства производится командой:\n\nsudo umount /dev/sdb1\n\nили\n\nsudo umount /home/user/Видео\n\n\n\nМожно монтировать командой auto\nsudo mount -t auto /home/user/Видео\nsudo mount -t auto /dev/sdb1 /home/user/Видео\n\n\nОтмонтировать\nsudo umount /dev/sdb1 /home/user/Видео"
  },
  {
    "objectID": "posts/mpg123/index.html",
    "href": "posts/mpg123/index.html",
    "title": "Mpg123",
    "section": "",
    "text": "Mpg123.Консольный аудиоплеер.\n\nЕсли у вас есть каталог, содержащий ваши любимые песни, вы можете воспроизвести их все, введя команду mpg123.\n\n$ mpg123 *.mp3\n\n\n\nГорячие клавиши управления(rus)\n\ns или [ ] - прерывание/возобновление воспроизведения (т.е. ‘(un)pause’)\nf - следующий трек\nd - предыдущий трек\nb - вернуться к началу трека\np - цикл вокруг текущей позиции (как поврежденный аудио компакт-диск;-)\n. - вперед\n, - перемотка назад\n: - перемотка вперед\n; - быстрая перемотка назад\n&gt; - вперед\n&lt; - точная перемотка назад\n+ - увеличить громкость\n- - убавить звук\nr - Переключатель RVA\nv - подробный переключатель\nl - список текущего плейлиста с указанием текущего трека\nt - отображать информацию о теге (снова)\nm - вывести информацию заголовка MPEG (снова)\nh - эта помощь\nq - закрыть\nc - или [C] шаг вверх (маленький шаг, большой шаг)\nx - или [X] шаг вниз (маленький шаг, большой шаг)\nw - сбросить высоту звука до нуля\n\nНажмите «h», чтобы просмотреть список клавиш и функций."
  },
  {
    "objectID": "posts/nano/index.html",
    "href": "posts/nano/index.html",
    "title": "Nano - консольный,текстовой редактор",
    "section": "",
    "text": "Редактор nano - это консольный текстовый редактор.Более “продвинутый” чем cat.\nОн есть во всех дистрибутивахLinux.\nОн есть в macOS и его можно запустить под Windows.\nnano часто используется для редактирования конфигурационных файлов, когда графический интерфейс отсутствует.\nУправление в nano осуществляется с клавиатуры с использованием горячих клавиш. В нижней части редактора приведен список основных сочетаний клавиш.\n\nСимвол ^ означает клавишу Ctrl.\nНапример:\n^X означает сочетание клавиш Ctrl+X. Регистр символов не учитывается, сочетание Ctrl+X эквивалентно Ctrl+x.\nРассмотрим, как выполнять основные действия при работе с nano.\n\nСоздать новый файл\nЧтобы создать файл достаточно просто запустить редактор без параметров.\nКогда вы будете закрывать редактор, то необходимо будет ввести имя файла.\n\nnano\n\nЕсли нужны номера строк запустить с опцией:\n\nnano -l\n\nТакже можно сразу задать имя нового файла:\n\nnano &lt;новый_файл&gt;\n\nПосле выполнения команды запустится редактор nano и в нем откроется для редактирования новый пустой файл.\n\n\nОткрыть существующий файл для редактирования\nЧтобы отредактировать существующий файл, необходимо запустить редактор nano и указать путь до файла, который нужно открыть:\n\nnano &lt;существующий_файл&gt;\n\n\n\nСохранение изменений\nВы отредактировали файл и хотите сохранить изменения, но не закрывать редактор. В таком случае используется сочетание клавиш:\n\nCtrl+O\n\n(это латинская буква -оу,а не ноль)\nВ строке статуса появится сообщение: File Name to Write: имя_файла (если имя файла отсутствует, о нужно ввести имя файла).\nДля сохранения изменений нажмите Enter.\n\n\nСохранить и выйти\nЧтобы сохранить изменения и выйти из редактора можно воспользоваться сочетанием клавиш:\n\nCtrl+X\n\nВ данном случае, если вы изменяли файл, то появится вопрос: “Save modified buffer (ANSWERING No Will DESTROY CHANGES)?”.\nНажмите клавишу y.\nПоявится вопрос на ввод имени файла.\nВведите новое имя файла или просто нажмите Enter.\nИзменения будут сохранены, редактор закроется.\n\n\nВыход без сохранения изменений\nЧтобы выйти из редактора и не сохранять изменения используется сочетание клавиш:\n\nCtrl+X\n\nЕсть появится вопрос “Save modified buffer ..?”, нажмите n.\n\n\nКопирование и вставка\nЧтобы вырезать строку целиком и поместить ее в буфер, переместите курсор на требуемую строку и нажмите:\n\nCtrl+K\n\nЧтобы вставить строку из буфера нажмите:\n\nCtrl+U\n\n\n\nКопирование и вставка произвольного текста\nЧтобы скопировать произвольный текст в буфер обмена, его необходимо сначала выделить. Чтобы начать выделение поместите курсор на начало текста, который планируется копировать, и нажмите:\n\nCtrl+6\n\nПеремещайте курсор, текст будет выделяться.\nЧтобы скопировать выделенный текст в буфер обмена, нажмите:\n\nAlt+6\n\nили, чтобы вырезать выделенный текст, нажмите:\n\nCtrl+K\n\nПереместите курсор в то место, куда необходимо вставить текст из буфера. Чтобы вставить текст из буфера нажмите:\n\nCtrl+U\n\n\n\nПоиск текста\nДля поиска текста внутри файла используется сочетание клавиш:\n\nCtrl+W\n\nНужно ввести строку для поиска и нажать Enter.\nКурсор будет помещен на первое вхождение искомого текста (относительно курсора). Чтобы перейти к следующему вхождению, нажмите:\n\nAlt+W\n\nЧтобы прекратить поиск, нажмите:\n\nCtrl+C\n\n\n\nПоиск и замена текста\nЧтобы найти и заменить текст используется сочетание клавиш:\n\nCtrl+\n\n\nПоявится запрос на ввод текста для поиска.\nВведи строку для поиска и нажмите Enter\nЗатем появится запрос на ввод текста, на который необходимо выполнить замену. Введите строку и нажмите Enter\nДалее будет выдан запрос на замену найденного вхождения искомой строки. Можно нажать клавишу A, чтобы заменить сразу все вхождения в файле или использовать клавиши Y или N, чтобы заменять или нет, найденные вхождения искомой строки.\n\n\nГорячие клавиши\nЧтобы вывести информацию по всем горячим клавишам, используется сочетание Ctrl+G.\n\nCtrl+A Переместить курсор в начало строки.\nCtrl+E Переместить курсор в конец строки.\nCtrl+Y Переместить курсор на 1 страницу вверх (аналог PageUp)\nCtrl+V Переместить курсор на 1 страницу вниз (аналог PageDown)\nCtrl+_ Перейти к определенной строке (нужно будет ввести номер строки)\nCtrl+C Показать на какой строке и в какой позиции находится курсор\nCtrl+W Поиск текста в файле. Необходимо ввести строку для поиска\nCtrl+  Поиск и замена текста в файле. Сначала вводится строка для поиска, затем строка для замены\nCtrl+D Удалить символ под курсором\nCtrl+K Удалить текущую строку\nCtrl+O Сохранить изменения, не закрывая редактор\nCtrl+X Выход из редактора. Если файл был изменен, появится запрос на сохранение изменений.\n\n\n\nКое-что еще\nЕще пара интересных трюков при работе с nano, о которых не все знают.\n\nCtrl = Esc Esc\n\nВместо клавиши Ctrl можно использовать двойное нажатие на клавишу Esc. Например:\n\nEsc+Esc+X\n\nЭто эквивалентно сочетанию Ctrl+X.\n\n\nТолько для чтения\nЧтобы открыть файл только для чтения используется ключ -v:\n\nnano -v &lt;файл&gt;\n\n\n\nРезервная копия файла\nМожно сделать так, чтобы при изменения файла создавалась его резервная копия.\nДля этого используется ключ -B:\n\nnano -B &lt;файл&gt;\n\nЕсли вы измените файл и сохраните изменения, то будет создана резервная копия файла, с содержимым файла, которое было до изменения.\nИмя резервной копии соответствует имени исходного файла со значком тильды ~ на конце.\n“ссылка”:\nnano\n\n\nКлючи:\n\n-A –smarthome Включить умную клавишу home\n-B –backup Делать резервные копии при сохранении\n-C &lt;каталог&gt; –backupdir=&lt;каталог&gt; Каталог сохранения уникальных резервных копий\n-D –boldtext Использовать жирный шрифт\n-E –tabstospaces Конвертировать табуляции в пробелы\n-F –multibuffer По умолчанию читать файл в новый буфер\n-G –locking Использовать файлы блокировки (как в vim)\n-H –historylog Сохранение & перезагрузка старых строк поиска/замены\n-I –ignorercfiles Не использовать на файлы nanorc\n-J &lt;число&gt; –guidestripe=&lt;число&gt; Показать линейку на этом столбце\n-K –rawsequences Решить проблему зависания цифровой клавиатуры\n-L –nonewlines Не добавлять пустую строку в конце\n-M –trimblanks Обрезать хвостовые пробелы при ручном переносе строк\n-N –noconvert Не преобразовывать из DOS/Mac формата\n-O –bookstyle Ведущий пробел означает новый параграф\n-P –positionlog Save & restore position of the cursor\n-Q &lt;regex&gt; –quotestr=&lt;regex&gt; Регулярное выражение для поиска кавычек\n-R –restricted Ограничить доступ к файловой система\n-S –softwrap Переносить длинные строки при просмотре\n-T &lt;число&gt; –tabsize=&lt;число&gt; Установить ширину табуляции\n-U –quickblank Очищать строку состояние при нажатии\n-V –version Показать версию и выйти\n-W –wordbounds Определять границы слов более точно\n-X &lt;строка&gt; –wordchars=&lt;строка&gt; Какие еще символы являются частью слова\n-Y &lt;имя&gt; –syntax=&lt;имя&gt; Использовать описание синтаксиса для подсветки\n-Z –zap Очищать выделенную область с помощью Bsp и Del\n-a –atblanks Делать мягкий перенос только на пробелах\n-b –breaklonglines Жестко переносить слишком длинные строки\n-c –constantshow Постоянно показывать позицию курсора\n-d –rebinddelete Решить проблему Backspace/Delete\n-e –emptyline Не занимать строку под строкой заголовком\n-f &lt;файл&gt; –rcfile=&lt;файл&gt; Использовать только этот файл для настроек nano\n-g –showcursor Показывать курсор и текст справки в файловом менеджере\n-h –help Показать этот текст и выйти\n-i –autoindent Автоматический отступ на новых строках\n-j –jumpyscrolling Прокрутка по пол-экрана, а не по строке\n-k –cutfromcursor Вырезать от курсора до конца строки\n-l –linenumbers Показывать номера строк перед текстом\n-m –mouse Разрешить использование мыши\n-n –noread Не читать файл (только писать его)\n-o &lt;каталог&gt; –operatingdir=&lt;каталог&gt;Установить рабочий каталог\n-p –preserve Зарезервировать кнопки XON (^Q) и XOFF (^S)\n-q –indicator Показать индикатор позиции+части\n-r &lt;число&gt; –fill=&lt;число&gt; Установить ширину для жесткого переноса и выравнивания\n-s &lt;программа&gt; –speller=&lt;программа&gt; Использовать эту альтернативную проверку правописания\n-t –saveonexit Не спрашивая сохранять изменения при выходе\n-u –unix По умолчанию сохранять файл в Unix формате\n-v –view Режим просмотра (только чтение)\n-w –nowrap Не переносить длинные строки [по умолчанию]\n-x –nohelp Не показывать две строки помощи внизу\n-y –afterends Останавливаться на краях слов при зажатом Ctrl+Right\n-! –magic Использовать магию для определения синтаксиса\n-% –stateflags Показывать состояния в строке заголовка\n-_ –minibar Отобразите панель обратной связи внизу\n-0 –zero Скрыть все панели, используя терминал"
  },
  {
    "objectID": "posts/rsync/index.html",
    "href": "posts/rsync/index.html",
    "title": "Команда rsync(резервное копирование)",
    "section": "",
    "text": "Взято из Википедии:\nrsync (англ. remote synchronization) — программа для UNIX-подобных систем, которая эффективно выполняет синхронизацию файлов и каталогов в двух местах (необязательно локальных) с минимизированием трафика, используя кодирование данных при необходимости. Важным отличием rsync от многих других программ/протоколов является то, что зеркалирование осуществляется одним потоком в каждом направлении (а не по одному или несколько потоков на каждый файл). rsync может копировать или отображать содержимое каталога и копировать файлы, опционально используя сжатие и рекурсию. rsync передаёт только изменения файлов, что отражается на производительности программы.\n\n\nsudo rsync -aAXvzh / –exclude={“/home/”,“/dev/”,“/proc/”,“/sys/”,“/tmp/”,“/run/”,“/mnt/”,“/media/”,“/lost+found”} /home/jenit/2024\n\n(перед exclude два тире)\nГде копируем корневой раздел (/).\nПрописываем директории которые исключаем из копирования (-exclude).\nКуда копируем (/home/jenit/2024).\nЯ пользуюсь этим способом для резервного копирования своей системы.\nПервый раз использования - будет копироваться вся система,затем ,при последующим копировании, только новые и измененные файлы и директории.\nВо время синхронизации можно удалять файлы (в старой копии), которых нет в источнике, для этого используется опция –delete.\n(перед delete два тире)\nНапример:\n\n$ sudo rsync -avzX –delete / –exclude={” /dev/* “,”/proc/* “,” /home/ * “,”/sys/* “,” /tmp/* “,” /run/* “,” /mnt/* “,” / media /* “,” /lost+found “} /mnt\n\n(перед delete два тире)\n\nВсе файлы, которых нет в новой копии, в старой будуд удалены.\n\nОбязательно исключите целевой каталог, если он существует в локальной системе, иначе будет бесконечный цикл копирования.\nЧтобы восстановить систему из резервной копии, просто измените исходные и целевые пути в приведенной выше команде.\n\nОпции\nТеперь давайте кратко рассмотрим параметры rsync. Здесь перечислены не все опции. Для более подробной информации смотрите man rsync:\n\n-v - Выводить подробную информацию о процессе копирования;\n-q - Минимум информации;\n-c - Проверка контрольных сумм для файлов;\n-a - Режим архивирования, когда сохраняются все атрибуты оригинальных файлов;\n-R - Относительные пути;\n-b - Создание резервной копии;\n-u - Не перезаписывать более новые файлы;\n-l - Копировать символьные ссылки;\n-L - Копировать содержимое ссылок;\n-H - Копировать жесткие ссылки;\n-p - Сохранять права для файлов;\n-g - Сохранять группу;\n-t - Сохранять время модификации;\n-x - Работать только в этой файловой системе;\n-e - Использовать другой транспорт, например, ssh;\n-z - Сжимать файлы перед передачей;\n-h - выводите числа в удобочитаемом формате\n-A - сохранить списки управления доступом\n-X - сохранение расширенных атрибутов\n–delete - Удалять файлы которых нет в источнике;\n–exclude - Исключить файлы по шаблону;\n–include - Включить файлы по шаблону\n–recursive - Перебирать директории рекурсивно;\n–no-recursive - Отключить рекурсию;\n–progress - Выводить прогресс передачи файла;\n–stat - Показать статистику передачи;\n–version - Версия утилиты."
  },
  {
    "objectID": "posts/sudo/index.html",
    "href": "posts/sudo/index.html",
    "title": "sudo",
    "section": "",
    "text": "sudo (Substitute User and do)\nsudo (англ. Substitute User and do, дословно «подменить пользователя и выполнить») — программа для системного администрирования UNIX-систем, позволяющая делегировать те или иные привилегированные ресурсы пользователям с ведением протокола работы.\nОсновная идея — дать пользователям как можно меньше прав, при этом достаточных для решения поставленных задач.\nПрограмма поставляется для большинства UNIX и UNIX-подобных операционных систем.\nКоманда sudo предоставляет возможность пользователям выполнять команды от имени суперпользователя root, либо других пользователей.\nПравила, используемые sudo для принятия решения о предоставлении доступа, находятся в файле /etc/sudoers (для редактирования файла можно использовать специальный редактор visudo, запускаемый из командной строки без параметров, в том числе без указания пути к файлу).\nЯзык их написания и примеры использования подробно изложены в man sudoers.\nВ большинстве случаев грамотная настройка sudo делает небезопасную работу от имени суперпользователя ненужной.\nВсе действия оказываются выполнимы из-под аккаунта пользователя, которому разрешено использовать sudo без ограничений.\nИмеется возможность запрещать и разрешать определённым пользователям или группам выполнение конкретного набора программ, а также разрешить выполнение определённых программ без необходимости ввода своего пароля.\n\nПримеры:\n\n\nРедактировани файла sudoers\n\nsudo vim /etc/sudoers\n\nРаскомментировать (убрать ‘#’ в начале строки) в /etc/sudoers строчку, дав права выполнять через sudo любую команду пользователям входящим в группу wheel, запрашивая их пароль:\nWHEEL_USERS ALL=(ALL) ALL\nС точки зрения безопасности правильнее давать права на выполнение sudo не всей группе wheel, а конкретному пользователю, например petya, входящего в группу «admin»:\npetya admin=(ALL) ALL\n\nРазрешить пользователям, входящим в группу «admin», выполнять команды с правами любого пользователя (с запросом пароля):\n%admin ALL=(ALL) ALL\n\n\nПозволить пользователю «user1» выполнять команды с правами «user2» или «user3», не запрашивая пароль:\nuser1 ALL=(user2, user3)NOPASSWD: ALL\n\n\nРазрешить пользователю «user» выполнять команду /usr/bin/rsync без запроса пароля:\nuser ALL=NOPASSWD: /usr/bin/rsync"
  },
  {
    "objectID": "posts/user/index.html",
    "href": "posts/user/index.html",
    "title": "Создание/Удаление пользователя",
    "section": "",
    "text": "Useradd vs Adduser\nuseradd - это низкоуровневая утилита для добавления новых пользователей\nadduser - дружественный интерактивный интерфейс для useradd, написанный на Perl.\nadduser является более удобным для пользователя и интерактивным, чем его серверная часть useradd.\nНет никакой разницы в предоставляемых функциях.\n\nДобавить/Удалить пользователя\n\nsudo adduser “user” - добавить пользователя\nsudo passwd “user” - задать пароль\nsudo usermod -a -G wheel “user” - добавить пользователя в группу wheel\nsudo userdel -r “user” - удалить пользователя и домашний каталог"
  },
  {
    "objectID": "posts/vim/vim.html",
    "href": "posts/vim/vim.html",
    "title": "Vim",
    "section": "",
    "text": "Самый лучший редактор “Всех Времен и Народов”\nЗдесь самые необходимые команды\n\nКоманды для Vim\n\n\n\nCopy / Paste\nДолжен быть установлен xclip или xsel\nПроверить командой:\n\n$ which xclip\n$ which xsel\n\nИз внешнего документа скопировать текст в vim:\n\nctrl+c\n\nи вставить в vim:\n\nctrl+shift+v or shift+insert (предпочтительнее)\n\nиз vim копировать в др.документ(редактор):\n\nshift+выделить текст\n\nвставить в др.документ(редактор):\n\nнажать среднюю кнопку мыши или ctrl+v\n\n\n\n\nОсновные команды\nvim &lt;’имя файла’&gt; - открыть файл в терминале\nvim &lt;‘path’&gt; &lt;’file_name’&gt; - открыть файл в терминале\n\n:q - выйти.\n:q! - выйти без сохранения.\n:w - сохранить.\ni - режим ввода.\nEsc - обычный режим.\nx - удалить символ.\n/ - поиск вперед\n? - Поиск назад\nn - Найти следующее вхождение\nN - Найти предыдущее вхождение\nd - удалить символ\ndd - удалить всю строку\nD - удалить символы начиная от курсора и до конца строки\ny - копировать символ\nyy или Y - скопировать всю строку\nv - выделить текст\np - вставить после позиции курсора\nP - вставить перед позицией курсора\nu - отменить последнее действие\n. - повторить еще раз последнее действие\nU - отменить последнее действие в текущей строке\n: № - Перемещение курсора на строку №…\n№G - Перемещение курсора на строку №…, аналогично :№…\ngg - Перемещение курсора в начало\nG - Перемещение курсора в конец\nw - Вперед на первую букву слова\ne - Вперед на последнюю букву слова\nb - Назад на первую букву слова\nge - Назад на последнюю букву слова\n$ - End На конец строки\n0 - (ноль), Home На начало строки\n\n\n\nДля переключения в режим редактирования используются такие команды:\n\ni - вставить текст с позиции курсора, символ под курсором будет заменен;\nI - вставить текст в начало строки;\na - добавить текст начиная от позиции курсора;\no - вставить новую строку после этой и начать редактирование;\nO - вставить новую строку перед этой и начать редактирование;\nr - заменить текущий символ;\nR - заменить несколько символов."
  },
  {
    "objectID": "posts/wget/index.html",
    "href": "posts/wget/index.html",
    "title": "Wget.Консольный менеджер загрузок.",
    "section": "",
    "text": "Wget - консольный менеджер загрузок.\nМожно с его помощью скачать изображения,видео,файлы,страницы сайта,сам сайт.\n\n\nОпции:\n\n-V (–version) - вывести версию программы\n-h (–help) - вывести справку\n-b (–background) - работать в фоновом режиме\n-o файл (–out-file) - указать лог файл\n-d (–debug) - включить режим отладки\n-v (–verbose) - выводить максимум информации о работе утилиты\n-q (–quiet) - выводить минимум информации о работе\n-i файл (–input-file) - прочитать URL из файла\n–force-html - читать файл указанный в предыдущем параметре как html\n-t (–tries) - количество попыток подключения к серверу\n-O файл (–output-document) - файл в который будут сохранены полученные данные\n-с (–continue) - продолжить ранее прерванную загрузку\n-S (–server-response) - вывести ответ сервера\n–spider - проверить работоспособность URL\n-T время (–timeout) - таймаут подключения к серверу\n–limit-rate - ограничить скорость загрузки\n-w (–wait) - интервал между запросами\n-Q (–quota) - максимальный размер загрузки\n-4 (–inet4only) - использовать протокол ipv4\n-6 (–inet6only) - использовать протокол ipv6\n-U (–user-agent)- строка USER AGENT отправляемая серверу\n-r (–recursive)- рекурсивная работа утилиты\n-l (–level) - глубина при рекурсивном сканировании\n-k (–convert-links) - конвертировать ссылки в локальные при загрузке страниц\n-P (–directory-prefix) - каталог, в который будут загружаться файлы\n-m (–mirror) - скачать сайт на локальную машину\n-p (–page-requisites) - во время загрузки сайта скачивать все необходимые ресурсы\n\n\n\nЗагрузка файла:\nКоманда wget linux скачает один файл и сохранит его в текущей директории. Во время загрузки мы увидим прогресс, размер файла, дату его последнего изменения, а также скорость загрузки:\n\nwget http://ftp.gnu.org/gnu/wget/wget-1.5.3.tar.gz\n\n\n\nСохранить файл с другим именем:\nОпция -О позволяет задать имя сохраняемому файлу, например, скачать файл wget с именем wget.zip:\n\nwget -O wget.zip http://ftp.gnu.org/gnu/wget/wget-1.5.3.tar.gz\n\n\n\nСкачать несколько файлов:\nВы можете скачать несколько файлов одной командой даже по разным протоколам, просто указав их URL:\n\nwget http://ftp.gnu.org/gnu/wget/wget-1.5.3.tar.gz ftp://ftp.gnu.org/gnu/wget/wget-1.10.1.tar.gz.sig\n\n\n\nВзять URL из файла:\nВы можете сохранить несколькоURL в файл, а затем загрузить их все, передав файл опции -i. Например создадим файл tmp.txt, со ссылками для загрузки wget, а затем скачаем его:\n\nwget -i /wget/tmp.txt\n\n\n\nПродолжить загрузку:\nУтилита wget linux рассчитана на работу в медленных и нестабильных сетях. Поэтому если вы загружали большой файл, и во время загрузки было потеряно соединение, то вы можете скачать файл wget с помощью опции -c.\n\nwget -c http://ftp.gnu.org/gnu/wget/wget-1.5.3.tar.gz\n\n\n\nЗагрузка файлов в фоне:\nОпция -b заставляет программу работать в фоновом режиме, весь вывод будет записан в лог файл, для настройки лог файла используются специальные ключи wget:\n\nwget -b -o ~/wget.log http://ftp.gnu.org/gnu/wget/wget-1.5.3.tar.gz\n\n\n\nОграничение скорости загрузки:\nКоманда wget linux позволяет не только продолжать загрузку файлов, но и ограничивать скорость загрузки. Для этого есть опция –limit-rate. Например ограничим скорость до 100 килобит:\n\nwget –limit-rate=100k ftp://ftp.iinet.net.au/debian/debian-cd/8.4.0/amd64/iso-dvd/debian-8.4. 0-amd64-DVD-1.iso\n\n\n\nЗагрузить и выполнить:\nВы, наверное, уже видели такие команды. wget позволяет сразу же выполнять скачанные скрипты:\n\nwget -O - http://сайт/скрипт.sh | bash\n\nЕсли опции -O не передать аргументов, то скачанный файл будет выведен в стандартный вывод, затем мы его можем перенаправить с интерпретатор bash, как показано выше.\n\n\nСохранить файл в папке:\nПо умолчанию wget сохраняет файл в текущую папку, но это поведение очень легко изменить с помощью опции -P:\n\nwget -P ~/Downloads/ http://ftp.gnu.org/gnu/wget/wget-1.5.3.tar.gz\n\n\n\nСкачать сайт:\nWget позволяет не только скачивать одиночные файлы, но и целые сайты, чтобы вы могли их потом просматривать в офлайне. Использование wget, чтобы скачать сайт в linux выглядит вот так:\n\nwget –mirror -p –convert-links -P ./ адрес_сайт\n\n\n\nЧтобы скачать сайт целиком с помощью wget нужно выполнить команду:\n\nwget http://site.com/\n\nПосле выполнения данной команды в директорию site.com будет загружена локальная копия сайта http://site.com.\nЧтобы открыть главную страницу сайта нужно открыть файлindex.html.\n\n\nРассмотрим используемые параметры:\n\n-r — указывает на то, что нужно рекурсивно переходить по ссылкам на сайте, чтобы скачивать страницы.\n-k — используется для того, чтобы wget преобразовал все ссылки в скаченных файлах таким образом, чтобы по ним можно было переходить на локальном компьютере (в автономном режиме).\n-p — указывает на то, что нужно загрузить все файлы, которые требуются для отображения страниц (изображения, css и т.д.).\n-l — определяет максимальную глубину вложенности страниц, которые wget должен скачать (по умолчанию значение равно 5, в примере мы установили 7). В большинстве случаев сайты имеют страницы с большой степенью вложенности и wget может просто «закопаться», скачивая новые страницы. Чтобы этого не произошло можно использовать параметр -l.\n-E — добавлять к загруженным файлам расширение .html.\n-nc — при использовании данного параметра существующие файлы не будут перезаписаны. Это удобно, когда нужно продолжить загрузку сайта, прерванную в предыдущий раз."
  },
  {
    "objectID": "posts/X11_vs_Wayland/X11_vs_Wayland.html",
    "href": "posts/X11_vs_Wayland/X11_vs_Wayland.html",
    "title": "Wayland vs X11",
    "section": "",
    "text": "Как узнать какой сервер установлен Wayland иди X11?\nПеременная XDG_SESSION_TYPE хранит тип сервера отображения, используемого системой.\nСледовательно, мы можем просто напечатать значение этой переменной в командной строке, чтобы определить, какой сервер отображения мы запускаем:\n\necho $XDG_SESSION_TYPE\n\nx11\n\necho $XDG_SESSION_TYPE\n\nwayland\nИз вывода для обоих случаев мы видим, что значениями для Xorg и Wayland будут «x11» и «wayland» соответственно.\nПеременная DESKTOP_SESSION может предоставить нам информацию о среде рабочего стола, которую в данный момент использует система, а также о сервере отображения:\n-echo $DESKTOP_SESSION\ngnome-xorg\n\necho $DESKTOP_SESSION\n\ngnome-wayland\nМы можем проверить переменную WAYLAND_DISPLAY чтобы определить, работает ли в нашей системе Wayland:\n\necho $WAYLAND_DISPLAY\n\nwayland-0\nВ случае с Wayland мы видим вывод «wayland-0»\nВ случае с Xorg вывода не будет\nВ Calculate + kde6 Plasma не получилось запустить Wayland.\nНашел вот это:\nWayland может не запускаться в Calculate из-за проблем с дисплейным менеджером (DM). По умолчанию в дистрибутиве используется sddm, который, по некоторым данным, не всегда корректно поддерживает запуск Wayland"
  },
  {
    "objectID": "posts/alien/Alien.html",
    "href": "posts/alien/Alien.html",
    "title": "alien - преобразования форматов между пакетами",
    "section": "",
    "text": "alien — компьютерная программа, созданная для преобразования форматов различных систем управления пакетами Linux.\n\nВозможности:\nПоддерживает преобразование между пакетами Linux Standard Base, RPM, deb, Stampede (.slp), Solaris (.pkg) и Slackware (.tgz). Способна автоматически устанавливать сгенерированный пакет. При преобразовании делает попытку конвертации инсталляционных скриптов, включённых в архив. Тем не менее последней возможностью следует пользоваться крайне осторожно, так как Linux-дистрибутивы могут сильно отличаться друг от друга и неудачно преобразованные скрипты могут повредить операционную систему.\n\n\nДля установки перейдите в сеанс пользователя root:\n\nsu -\npass\n\nУзнать установлен ли alien командой:\n\nwhich alien\n\nЕсли нет установить (Fedora, RosaFresh, РЕД ОС…):\n\ndnf install alien\n\n(или командой для Вашего пакетного менеджера)\n\n\nИспользование:\nПростой пример использования alien:\n(команды выполняются из под root - супер пользователя)\n\nalien –to-rpm –scripts ./mypkg.deb\n\nЭто позволит сконвертировать mypkg.deb в mypkg.rpm с преобразованием стандартных для Debian пакета инсталляционных скриптов — preinst, postinst, prerm и postrm[2]. На выходе получится RPM-пакет.\nОбратная задача решается следующей командой\n\nalien –to-deb –scripts ./mypkg.rpm\n\nЭто позволит сконвертировать mypkg.rpm в mypkg.deb\n\n\nНу и установить сам пакет mypkg.deb или mypkg.rpm\n\n\nКлючи и атрибуты alien\n\nfile […] – задать список файлов пакета для конвертирования;\n-to-deb, -d – конвертировать в deb (используется приложением “по умолчанию”);\n-to-rpm, -r – конвертировать в rpm;\n-to-tgz, -t – создать tgz-пакет;\n-to-slp – создать Stampede slp пакет;\n-to-lsb, -l – создать LSB пакет;\n-to-pkg, -p – создать Solaris pkg пакет;\n-i – автоматически установить все сгенерированные пакеты и после этого удалить сам файл пакета;\n-g – сгенерировать дерево построения, не создавая пакет;\n-c – включить скрипты в пакет;\n-v – отображать каждую команду, которую выполняет alien;\n-k – не менять версию генерируемых пакетов;\n-V – показать номер версии alien;\n-h – показать справку.\n\nВыполните alien -h, чтобы увидеть доступные параметры.\n\n\nВзято:\nAlien - wiki\nAlien - РЕД ОС"
  },
  {
    "objectID": "posts/less/less.html",
    "href": "posts/less/less.html",
    "title": "less",
    "section": "",
    "text": "Less — это утилита командной строки, которая отображает содержимое файла или вывод команды по одной странице за раз. Он похож на more, но имеет более продвинутые функции и позволяет перемещаться по файлу как вперед, так и назад. При запуске less не читает весь файл, что приводит к гораздо более быстрой загрузке по сравнению с текстовыми редакторами, такими как vim или nano.\nЗапись команды less в терминале выглядит так:\n\nless ‘опции файл’\n\n\nНаиболее популярные опции:\n\n-a, –search-skip-screen — не осуществлять поиск в тексте, который в данный момент отображен на экране;\n-bn, –buffers=n — задать размер буфера памяти;\n-c, –clear-screen — листать текст, полностью стирая содержимое экрана (построчная прокрутка работать не будет);\n-Dxcolor, –color=xcolor — задать цвет отображаемого текста;\n-E, –QUIT-AT-EOF — выйти, когда утилита достигнет конца файла;\n-e, –quit-at-eof — выйти, когда утилита второй раз достигнет конца файла;\n-F, –quit-if-one-screen — выйти, если содержимое файла помещается на одном экране;\n-f, –force — открыть специальный файл;\n-hn, –max-back-scroll=n — задать максимальное количество строк для прокрутки назад;\n-yn, –max-forw-scroll=n — задать максимальное количество строк для прокрутки вперёд;\n-i, –ignore-case — игнорировать регистр;\n-I, –IGNORE-CASE — игнорировать регистр, даже если паттерн для поиска содержит заглавные буквы;\n-jn, –jump-target=n — указать, в какой строке должна быть выведена искомая информация;\n-J, –status-column — пометить строки, соответствующие результатам поиска;\n-n, –line-numbers — не выводить номера строк;\n-N, –LINE-NUMBERS — вывести номера строк;\n-s, –squeeze-blank-lines — заменить множество идущих подряд пустых строк одной пустой строкой;\n-w, –hilite-unread — выделить первую строку нового фрагмента текста.\n\nВо время просмотра текста утилитой можно управлять при помощи внутренних команд, набирая их на клавиатуре компьютера:\n\n\nНаиболее часто используемые из них\n\nh, H — справка;\nSpace, Ctrl+V, f, Ctrl+F — прокрутить текст на один экран вперёд;\nEnter, Return, Ctrl+N, e, Ctrl+E, j, Ctrl+J — прокрутить текст на n строк вперед, по умолчанию n=1;\ny, Ctrl+Y, Ctrl+P, k, Ctrl+K — прокрутить текст на n строк назад, по умолчанию n=1;\nCtrl+→ — прокрутить текст по горизонтали в конец строки;\nCtrl+← — прокрутить текст по горизонтали в начало строки;\n\n(или просто управлять стрелками чтобы прокрутить текст: вправо, влево, вперед, назад)\n\n:d — удалить текущий файл из списка файлов;\nCtrl+G, :f — вывести основную информацию о файле;\nq, Q, :q, :Q, ZZ — выход.\n\nПеречень всех опций и внутренних команд можно просмотреть в терминале, выполнив команду:\n\nman less"
  },
  {
    "objectID": "posts/more/more.html",
    "href": "posts/more/more.html",
    "title": "more",
    "section": "",
    "text": "Утилита more предназначена для постраничного просмотра файлов в терминале Linux. Своим названием она обязана надписи more (в русскоязычном варианте — дальше), появляющейся внизу каждой страницы\nКоманда more в операционной системе Linux позволяет просматривать содержимое текстового файла по одной странице за раз. Это особенно полезно при работе с большими файлами, так как предотвращает быстрое пролистывание вывода за пределы экрана и облегчает навигацию по содержимому.\nКоманда more в linux — одна из самых примитивных команд для работы с текстом. Её ближайшая родственница — команда less — обладает куда большим набором опций и дополнительных возможностей.\n\nСИНТАКСИС И ОПЦИИ MORE\nВ эмуляторе терминала Linux команда вызывается так:\n\nmore ‘опции файл’\n\nСписок опций команды:\n^ - то же, что и Ctrl\n\n-d — вывод информации в конце страницы о клавишах, использующихся для продолжения работы, завершения её или получения инструкций;\n-l — игнорирование в тексте символа разрыва страницы;\n-f — подсчёт числа логических строк вместо экранных;\n-p — очистка экрана терминала для того, чтобы пользователю не пришлось пользоваться прокруткой перед выводом следующей порции текста;\n-c — устранение потребности в прокрутке (как и -p) — отображение текста, начиная с верха экрана, и стирание при этом предыдущего вывода построчно;\n-s — замена нескольких пустых строк, расположенных подряд, одной пустой строкой;\n-u — удаление подчёркивания;\n-n — отображение n-го количества строк;\n+n — отображение текста, начиная со строки с номером n;\n+/строка — поиск в файле указанной строки и начало вывода текста именно с неё;\n–help — вызов справки;\n-v (–version) — вывод на экран текущей версии утилиты.\n\nТакже у команды more есть собственные горячие клавиши и интерактивные команды:\n\nh (?) — помощь (вывод информации только об интерактивных командах);\nПРОБЕЛ — отображение следующей порции текста (по умолчанию количество строк зависит от текущего размера окна терминала);\nz — то же, что и ПРОБЕЛ;\nENTER — вывод текста построчно (шаг команды — одна строка);\nd (^D) — прокрутка текста на количество строк, соответствующее размеру терминала;\nq (Q) — выход из утилиты;\ns — переход на одну строку вперёд;\nf — переход на одну экранную страницу вперёд;\nb (^B) — переход на одну экранную страницу назад;\n’ — возвращение к месту начала поиска;\n= — отображение текущего количества строк;\n/pattern — поиск с использованием регулярных выражений;\nn — поиск слов и фраз, соответствующих последнему использованному регулярному выражению;\n!command (:command) — выполнение команды в субоболочке;\nv — открытие файла в текстовом редакторе, назначенном по умолчанию, а если таковой не найден, использование консольного текстового редактора для открытия файла;\n^L — удаление с экрана всего, кроме содержимого файла;\n:n — переход к следующему файлу;\n:p — переход к предыдущему файлу;\n:f — вывод названия текущего файла и количества строк в нём;\n. - повторное выполнение предыдущей команды.\n\n\n\nПРИМЕРЫ ИСПОЛЬЗОВАНИЯ MORE\nДля того, чтобы просмотреть текст из файла, применяется команда:\n\nmore example-file-for-more-command.txt\n\nТакже в команде можно перечислить несколько имён файлов одно за другим, разделяя их пробелом. Содержимое этих файлов будет выведено в том же порядке. Пример:\n\nmore abc1.txt dfg2.txt\n\nНапример, для того, чтобы узнать номер текущей строки, следует нажать клавишу:\n\n=\n\nЧтобы просмотреть файл в текстовом редакторе клавишу:\n\nv\n\nДля того, чтобы получить список всех интерактивных команд, следует нажать клавишу:\n\nh"
  },
  {
    "objectID": "posts/pandoc/pandoc.html",
    "href": "posts/pandoc/pandoc.html",
    "title": "pandoc-конвертирование файлов",
    "section": "",
    "text": "Pandoc — универсальная утилита («швейцарский нож») для работы с текстовыми форматами. Основная сфера применения — форматирование математических и технических текстов.\n\nВходные форматы:\nmarkdown, reStructuredText, HTML, LaTeX, OPML, Org-mode, DocBook, и Office Open XML (Microsoft Word .docx).\n\n\nВыходные форматы:\n\n\nформаты на основе HTML:\nXHTML, HTML5, HTML-слайды презентаций (S5, Slidy, Slideous, DZSlides)\n\n\nформаты текстовых процессоров:\nMicrosoft Word docx, OpenOffice/LibreOffice ODT, OpenDocument XML\n\n\nэлектронные книги:\nEPUB версии 2 или 3, FictionBook2\n\n\nформаты технической документации:\nDocBook, GNU TexInfo, groff[en]\n\n\nформаты системы ΤΕΧ:\nLaTeX, ConTeXt, слайды LaTeX Beamer\n\n\nPDF (с помощью LaTeX):\n\n\nтекстовые форматы с облегчённой разметкой:\nMarkdown, reStructuredText, AsciiDoc, MediaWiki, Emacs Org-Mode, Textile\n\n\nТакой метод конвертации:\npandoc -o sample.html sample.md\npandoc -o sample.odt sample.md\npandoc -o sample.txt sample.md\n---\npandoc -f markdown -t latex -s -o sample.tex sample.md\n-o (out) выходной формат файла\n( -f (от) и -t (для) варианты используются, чтобы сказать pandoc какие\nформаты файлов вы хотите конвертировать из и в )\npdflatex main.tex - from terminal make pdf\n\n\nКонвертирование файлов .docx in .md(с картинками и таблицами)\nВ папке где находится файл *.docx открыть терминал и выполнить команду:\n\npandoc -t gfm –extract-media . “fan guide.docx” -o main.md\n\n\n\n\nУказание форматов файлов(LaTeX)\nПараметры -f (от) и -t (до) используются, чтобы указать pandoc, какие форматы файлов вы хотите преобразовать ИЗ и В.\nЭто может быть полезно, если вы работаете с форматом файла, который имеет расширение файла с другими родственными форматами. Например, TeX, и Латекс оба используют расширение «.tex».\nМы также используем параметр -s (автономный), чтобы pandoc сгенерировал всю преамбулу LaTeX, необходимую для того, чтобы документ был полным, самодостаточным и правильно сформированным документом LaTeX.\nБез опции -s (автономный) вывод все равно был бы правильно сформированным LaTeX, который можно было бы вставить в другой документ LaTeX, он не мог бы правильно анализироваться как отдельный документ LaTeX.\n\n\nНабираем следующее:\n\npandoc -f markdown -t latex -s -o sample.tex sample.md\n\nНужно в готовом *.tex сделать небольшую правку как то:\n\n\nИсправить на:\n\nusepackage[T2A]{fontenc}\n\n\n\nДобавить:\n\nusepackage[english,russian]{babel}\n\n\n\nGUI Editor\nЕсли у вас есть редактор LaTeX, вы можете открыть файл TEX, чтобы предварительно увидеть, как интерпретируются команды набора LaTeX.\nЕсли вы откроете файл «sample.tex» в редакторе (редактор LaTeX под названием Texmaker), вы увидите сгенерированный LaTeX.\nПОЛУЧАЕМ ГОТОВЫЙ PDF ФАЙЛ!!!\n\n\nTerminal (console)\nДля создания PDF-файла укажите выходной файл с .pdf-расширением:\n\npandoc test.txt -o test.pdf\n\nor\n\npandoc test.txt -V lang=RU-ru -o test.pdf\n\nили лучше так,с указанием шрифта:\n\npandoc –pdf-engine=xelatex -V ‘mainfont:Arial’ -t beamer test.txt -o test.pdf\n\n(нужен установленный шрифт Arial)\nПо умолчанию pandoc будет использовать LaTeX для создания PDF, для чего требуется установить механизм LaTeX\n\n\nСоздание pdf в терминале\n*** При условии что установлен LaTeX***\nLaTeX:\n\npdflatex simple.tex\n\nXeTeX:\n\nxelatex simple.tex\n\nLuaTeX:\n\nluatex simple.tex\n\n\n\nДля преобразования hello.html из HTML в Markdown:\n\npandoc -f html -t markdown hello.html\n\nФормат ввода и вывода может быть указан явно с помощью параметров командной строки. Формат ввода можно указать с помощью -f/–from опции, формат вывода - с помощью -t/–to опции.\n\n\nТаким образом, чтобы преобразовать hello.txt Markdown в LaTeX, вы можете ввести:\n\npandoc -f markdown -t latex hello.txt\n\n\n\nИспользование pandoc без файлов – .md make in terminal\nЕсли вы используете pandoc без каких-либо параметров командной строки, он также принимает типизированный ввод. Вы просто нажимаете Ctrl + D, чтобы указать, что вы закончили печатать.pandoc ожидает, что вы наберете в формате Markdown, и он генерирует вывод HTML.\n\n\nДавайте посмотрим на пример:\npandoc\n# level\n## level\n### level\nМы набрали несколько строк Markdown и собираемся нажать Ctrl + D.\n\n\nПреобразование файлов с помощью шаблонов (CSS)\nВы, наверное, начинаете понимать гибкость, которую предоставляет pandoc. Вы можете написать один раз и опубликовать практически в любом формате. Это великий подвиг, но документы действительно выглядят немного ванильными.\nС помощью шаблонов вы можете указать, какие стили использует pandoc при создании документов. Например, вы можете указать pandoc использовать стили, определенные в Каскадные таблицы стилей (CSS) файл с параметром –css.\nМы создали небольшой файл CSS, содержащий текст ниже. Он изменяет интервал выше и ниже уровня заголовка на один стиль. Он также изменяет цвет текста на белый, а цвет фона на оттенок синего:\nh1 {\n\n  color: #FFFFFF;\n\n  background-color: #3C33FF;\n\n  margin-top: 0px;\n\n  margin-bottom: 1px;\n\n}\nПолная команда приведена ниже — обратите внимание, что мы также использовали автономную опцию (-ы):\n\npandoc -o sample.html -s –css sample.css sample.md\n\npandoc использует единый стиль из нашего минималистичного файла CSS и применяет его к заголовку первого уровня."
  },
  {
    "objectID": "posts/poppler/poppler.html",
    "href": "posts/poppler/poppler.html",
    "title": "poppler-конвертирование PDF в изображения",
    "section": "",
    "text": "Для конвертации PDF в различные форматы можно воспользоваться poppler-utils.\nPoppler — это библиотека рендеринга PDF, основанная на кодовой базе XPDF-3.0. Она используется для обработки PDF-файлов и позволяет разработчикам создавать программы для чтения и редактирования PDF-документов.\nPoppler поддерживает множество операционных систем, включая Linux, macOS и Windows.\nВ пакете содержатся основанные на Poppler инструменты командной строки для получения информации о PDF-документах, их преобразованиях в другие форматы и редактированиях.\nВ poppler-utils есть несколько программ, с помощью которых можно преобразовать PDF-документ в различные форматы:\n\npdftocairo — преобразование из PDF в PNG, JPEG, PDF, PS, EPS и SVG на основе Cairo;\n\n\nConvert PDF to JPEG:\n\npdftocairo {{path/to/file.pdf}} -jpeg *.jpg\npdftocairo -jpeg -f 2 -l 4 .pdf .jpg\n(от… и до…)\n\n\n\nConvert PDF to PNG\n\npdftocairo -png .pdf .png\n\n\n\nпреобразование из PDF в HTML;\n\npdftohtml .pdf .html\n\n\n\nпреобразование из PDF в изображения PPM;\n\npdftoppm example.pdf example\n\n\n\nпреобразование из PDF в PostScript (PS);\n\npdftocairo -ps .pdf .ps\n\n\n\nConvert pdf to svg:\n\n$ pdftocairo -svg -f 1 -l 19 test.pdf test.svg\n\nгде:\n\nf - начальная страница\nl - последняя страница\ntest.pdf - что конвертируем\ntest.svg - во что конвертируем\n\nЕсли вам нужно преобразовать PDF-документ в какой-либо другой формат, можно воспользоваться одной из доступных утилит.\n\n\nНапример, преобразование PDF в PS осуществляется командой:\n\npdftocairo -ps example.pdf example.ps\n\n\n\nИзвлечение изображений из файла PDF\nПроцедура извлечения очень проста. Просто следуйте следующему синтаксису.\n\npdfimages -all input.pdf images/prefix\n\nПриведенная выше команда берет все изображения из входного файла input.pdf и извлекает их в тот же каталог, что и запрос. Конечно, вы можете задать абсолютный путь к месту, где находится PDF-файл, и другой путь для выходного файла.\nЧто касается images/prefix, то идеальным вариантом будет выбрать такой, который хорошо идентифицирует изображения, а также формат jpeg или png, из которых два PNG обеспечивают более высокое качество.\nПосле вышесказанного команда будет выглядеть следующим образом.\n\npdfimages -all input.pdf sample\n\nВ результате в каталоге будут созданы файлы изображений с такой номенклатурой sample-nnn.png.\nЕсли вы хотите использовать jpg, то добавьте опцию -j\n\npdfimages -all -j input.pdf sample\n\nЧто касается опции -j, вы можете не получить желаемых результатов\n\n\nДополнительные опции для извлечения изображений\nПриведенная выше команда извлекает все изображения, но во многих случаях мы хотим определить диапазон. Важный параметр, если файл очень длинный.\nДля этого существуют опции -f и -l, которые определяют первую и последнюю страницу, с которой нужно извлечь изображения.\n\npdfimages -f 1 -l 5 -png input.pdf images\n\nЭто, пожалуй, самая полезная опция, поскольку она позволяет нам ограничить выходные файлы.\nДругой очень интересной опцией является параметр -p, которая включает номера страниц в имена выходных файлов.\n\npdfimages -f 1 -l 5 -png -p input.pdf images\n\n\n\nВ пакет Poppler входит несколько консольных утилит для работы с PDF-файлами:\n\npdfdetach — отображает наличие и извлекает встроенные файлы\npdffonts — анализатор шрифтов\npdfimages — извлекает изображения\npdfinfo — отображает свойства документа\npdfseparate — извлечение отдельных страниц\npdftocairo — конвертер в форматы PNG, JPEG, PDF, PS (PostScript), EPS, SVG с использованием Cairo\npdftohtml — конвертер в HTML\npdftoppm — конвертер в изображения PPM, PNG, JPEG\npdftops — конвертер в PS\npdftotext — конвертер в текстовый файл\npdfunite — объединение документов\n\n\n\nShort Descriptions\n\npdfattach\n\nдобавляет новый встроенный файл в существующий файл PDF\n\npdfdetach\n\nперечисляет или извлекает встроенные файлы из файлов PDF\n\npdffonts\n\nперечисляет шрифты, используемые в файле PDF, а также различные информация для каждого шрифта\n\npdfimages\n\nсохраняет изображения из файла PDF в виде файлов PPM, PBM или JPEG\n\npdfinfo\n\nпечатает содержимое словаря Info (плюс некоторые другая полезная информация) из PDF-файла\n\npdfseparate\n\nизвлекает отдельные страницы из файла PDF\n\npdfsig\n\nпроверяет цифровые подписи в PDF-документе\n\npdftocairo\n\nконвертирует PDF-файл в один из нескольких форматов (PNG, JPEG, PDF, PS, EPS, SVG) с помощью устройства вывода cairo библиотека попплера\n\npdftohtml\n\nконвертирует PDF-файл в HTML\n\npdftoppm\n\nконвертирует PDF-файлы в форматы PBM, PGM и PPM\n\npdftops\n\nконвертирует PDF-файлы в формат Postscript\n\npdftotext\n\nконвертирует PDF-файлы в обычный текст\n\npdfunite\n\nобъединяет несколько PDF-файлов в порядке их появление в командной строке в один выходной файл PDF\nПример:\n\n$ pdfunite 1.pdf 2.pdf 3.pdf"
  },
  {
    "objectID": "posts/ffmpeg(audio_from_video_all)/ffmpeg_(audio_from_video_all).html",
    "href": "posts/ffmpeg(audio_from_video_all)/ffmpeg_(audio_from_video_all).html",
    "title": "Извлечь звук из всех видео в папке",
    "section": "",
    "text": "Извлечь звук из всех видео в папке. Создает папку cash, туда извлекаются звуковые файлы. Битрейт(качество звука) можно настроить,изначально битрейт -ab 128k.\nСкопировать все и вставить в терминал.\nmkdir cash\n\nfor f in *.avi *MOV *.mkv *.mp4 *.mpg ;\n \ndo\n\nffmpeg -i \"$f\" -vn -ar 44100 -ac 2 -ab 128k -f mp3 cash/\"${f%.*}\".mp3\n \ndone\nЗапустить -&gt; Enter"
  },
  {
    "objectID": "posts/ffmpeg(audio_from_video_one)/ffmpeg_(audio_from_video_one).html",
    "href": "posts/ffmpeg(audio_from_video_one)/ffmpeg_(audio_from_video_one).html",
    "title": "Извлечение аудио из видео(один файл)",
    "section": "",
    "text": "Извлечение аудио из видео(один файл)\nffmpeg -i INPUT.mp4 -vn -c:a libmp3lame -ab 64k OUTPUT.mp3\n\n-i INPUT.mp4 - входной файл(input)\nOUTPUT.mp3 - выходной файл(output)\n-vn - видео нет(без видео)\n-c:a libmp3lame - кодек аудио\n-ab 64k - битрейт(качество звука можно менять)"
  },
  {
    "objectID": "posts/ffmpeg_mp3_in_ogg_vorbis/ffmpeg_mp3_in_ogg_vorbis.html",
    "href": "posts/ffmpeg_mp3_in_ogg_vorbis/ffmpeg_mp3_in_ogg_vorbis.html",
    "title": "Конвертировать mp3 в ogg_vorbis",
    "section": "",
    "text": "Один *.mp3 файл.\nffmpeg -i input.mp3 -c:a libvorbis -q:a 4 output.ogg\n\n\nЦелый каталог с MP3-файлами:\nfor f in ./*.mp3; do ffmpeg -i \"$f\" -c:a libvorbis -q:a 4 \"${f/%mp3/ogg}\"; done\n\n\nРекурсивно:\nfind . -type f -name '*.mp3' -exec bash -c 'ffmpeg -i \"$0\" -c:a libvorbis -q:a 4 \"${0/%mp3/ogg}\"' '{}' \\;\nУстановите качество вывода, отрегулировав значение-q:a: для этого кодека диапазон составляет 0-10, и чем выше значение, тем лучше качество\nВ старых версиях ffmpeg, вам может понадобиться использовать -acodec и -aq вместо -c:a и -q:a"
  },
  {
    "objectID": "posts/ffmpeg_Склейка_медиа_файлов/ffmpeg_Склейка_медиа.html",
    "href": "posts/ffmpeg_Склейка_медиа_файлов/ffmpeg_Склейка_медиа.html",
    "title": "Склейка медиа-файлов",
    "section": "",
    "text": "Вот как я это запустил!!!:\nПоместить все входные медиа-файлы в одну папку\nсоздавать input.txt в этой папке\nсодержимое выглядит так:\n\nfile ‘input1.mp4’\nfile ‘input2.mp4’\nfile ‘input3.mp4’\nfile ‘input4.mp4’\n\n\n\nПримечание:\nкодировка файла должна быть UTF-8\nfile - ключевое слово должно присутствовать\nимя файла не должно быть полным (я получал исключения, используя ‘/path/to/input1.mp4’\nимя файла должно быть заключено в ‘ ’\nперейдите в эту папку\nвыполнять в терминале:\nffmpeg -f concat -i input.txt -c copy ffmpegOUT.mp4\n\n\nСклейка медиа-файлов №2\n(у меня почему-то этот вариант не сработал)\nСобрать несколько частей вместе.\nДля этого вам нужно будет создать новый текстовый файл и начать редактировать его, используя предпочитаемый вами редактор. В примере мы будем использовать touch и &gt;vim.\nНеважно, как вы называете этот файл.\nНапример, назовем его join.txt и создадим, используя touch:\ntouch videos_to_join.txt\nТеперь отредактируем его в vim\nvim videos_to_join.txt\nЗдесь введите полные пути ко всем файлам, которые вы хотите присоединить (они будут объединены в том порядке, в котором вы их здесь пишете), по одному на строку. Убедитесь, что они имеют одинаковое расширение (например, mp4).\nВот пример:\n/home/ubuntu/Desktop/video_1.mp4\n/home/ubuntu/Desktop/video_2.mp4\n/home/ubuntu/Desktop/video_3.mp4\nСохраните файл, который вы только что отредактировали. Этот метод работает для любых аудио или видео файлов.\nТеперь введите следующее:\nffmpeg -f concat -i join.txt output.mp4\nffmpeg -f concat -i list.txt -c copy output.mp4\nПримечание: наш выходной файл - output.mp4, потому что все наши входные файлы имеют расширение mp4.\nЭто должно объединить все файлы, которые мы записали в join.txt, в один выходной файл."
  },
  {
    "objectID": "posts/vimcommander/vimcommader_plugin.html",
    "href": "posts/vimcommander/vimcommader_plugin.html",
    "title": "vimcommander - FM",
    "section": "",
    "text": "Файловый менеджер, работающий в vim. Я настроил окрытие его по F2 вместо продлагаемого F11. Просто мне так удобнее.\n\nУстановка\nСкачать\nПеретащите vimcommander.vim в ~/.vim/plugin\nДобавьте в свой .vimrc сопоставление с VimCommanderToggle() следующим образом:\nnoremap &lt;silent&gt; &lt;F11&gt; :cal VimCommanderToggle()&lt;CR&gt;\n\n\nИспользование\nvimcommander открывает две панели проводников файлов в верхней половине экрана vim.\nЦели для перемещения и копирования значений по умолчанию на другую панель, например totalcmd.\nTAB переключает между панелями.\nКлючи Vimcommander в основном совпадают с ключами totalcommander:\nF3 - просмотр\nF4 - редактирование\nF5 - копировать\nF6 - переместить\nF7 - создать каталог\nF8 - удалить\nF9 - sshconnect\nДругие: CU, C-Left/C-Right, CR, BS, DEL, CH и т. д.\nВыбор файлов/каталогов также работает: INS, +, -. Затем копируйте/перемещайте/удаляйте выбранные файлы.\nПредлагаемое связывание\nnoremap &lt;silent&gt; &lt;F11&gt; :cal VimCommanderToggle()&lt;CR&gt;\nПроверено на Linux. У меня есть сведения, что на Windows это не работает.\nhttps://github.com/Alukardd/vimcommander"
  },
  {
    "objectID": "posts/vi_hotkey/vi_hotkey.html",
    "href": "posts/vi_hotkey/vi_hotkey.html",
    "title": "vi keyboard shortcuts",
    "section": "",
    "text": "vi (от англ. visual, по-русски читается «ви-ай») — серия текстовых редакторов операционных систем семейства UNIX.\n\nПеремещение\nВлево, вниз, вверх, вправо - h, j, k, l\nВ конец строки - $\nВ начало строки - ^\nВ конец файла - G\nВ начало файла - :1\nНа строку 47 - :47\n\n\nРедактирование\nУдаление строки - dd\nУдаление пяти строк - 5dd\nЗамена символа - r\nУдаление символа - x\nУдаление десяти символов - 10x\nОтмена последнего действия - u\nОбъединение текущей и следующей строк - J\nвводить текст со следующей строки - o\nОтдельные части текста можно заменять на другие.Подведите курсор к первому символу в слове, нажмите клавишу - R\nЗамена старого на новое, глобально - %s старое / новое g\n\n\nПоиск\nПоиск “asdf” - /asdf\nПоиск “asdf” в обратном направлении - ?asdf\nПовтор последнего поиска в прямом направлении - /\nПовтор последнего поиска в обратном направлении - ?\nПовтор последнего поиска в том же направлении - n\nПовтор последнего поиска в обратном направлении - N\n\n\nСохранение и выход\nВыйти - :q\nВыйти без сохранения - :q!\nЗаписать и выйти - :wq\nЗаписать без выхода - :w\nПерезагрузить открытый в данный момент файл - :e!\nЗаписать буфер в файл asdf - :w asdf\nОткрыть файл hejaz - :e hejaz\nЗагрузить файл asdf в буфер - :r asdf\nЗагрузить вывод команды ls в буфер - :r !ls"
  },
  {
    "objectID": "posts/vim_hotkey/vim_hotkey.html",
    "href": "posts/vim_hotkey/vim_hotkey.html",
    "title": "vim keyboard shortcuts",
    "section": "",
    "text": "Горячие клавиши для vim\n\nСамые главные команды:\nvim &lt;’имя файла’&gt; - открыть файл в терминале\n:q - выйти из vim(закрыть)\n:wq - записать(сохранить документ) и выйти\n:q! - выйти без сохранения\n:w - сохранить файл; \n:buffers - посмотреть открытые файлы.\nCtrl+P - оно с буферами умеет работать, с недавно открывавшимися файлами и интуитивно понятно работает.\n\n\n_Это тоже может очень пригодится:\nИз внешнего документа скопировать текст_ - ctrl+c\nи вставить в _vim_ - ctrl+shift+v\nor \nshift+insert(предпочтительнее)\nиз _vim_ копировать в др.документ - shift+выделить текст,\nвставить в др.документе - нажать среднюю кнопку мыши или ctrl+v\n**_Работает в Ubuntu 20,Slackware 15 - точно!_**\n**_Будут нужны установленные xclip,xsel_**\n\n\nПеремещение по тексту(нормальный режим):\nh - Влево\nl(L) - Вправо\nj - Вниз\nk - Вверх\nw - Вперед на первую букву слова\ne - Вперед на последнюю букву слова\nb - Назад на первую букву слова\nge - Назад на последнюю букву слова\nd - удалить символ;\ndd - удалить всю строку;\nD - удалить символы начиная от курсора и до конца строки;\ny - копировать символ;\nyy или Y - скопировать всю строку;\nv - выделить текст;\np - вставить после позиции курсора;\nP - вставить перед позицией курсора;\nu - отменить последнее действие;\n. - повторить еще раз последнее действие;\nU - отменить последнее действие в текущей строке;\n/шаблон - искать вхождение;\n%s/шаблон/заменить - заменить первое слово на второе;\nn - продолжить поиск вперед;\nN - продолжить поиск назад;\nW - То, же, что и w, но словом считается то, что отделено пустыми символами\nE - То, же, что и e, но словом считается то, что отделено пустыми символами\nB - То, же, что и b, но словом считается то, что отделено пустыми символами\ngE - То, же, что и ge, но словом считается то, что отделено пустыми символами ^ На первый непустой символ строки\n$, - End На конец строки\n0 - (ноль), Home На начало строки\n( - На первую точку слева от курсора (если она есть, в противном случае на начало абзаца)\n) - На первую точку справа от курсора (если она есть, в противном случае на конец абзаца)\n{ - На абзац назад до пустой строки\n} - На абзац вперед до пустой строки\ngj - На одну экранную строку вниз. Экранная строка — это целая строка длиной меньше ширины экрана, либо часть длинной строки, разделенной на экране на несколько\ngk - На одну экранную строку вверх.\nf# - Поиск вперед в строке символа # и установка курсора на него\nF# - Поиск назад в строке символа # и установка курсора на него\nt# - Поиск вперед в строке символа # и установка курсора после него\nT# - Поиск назад в строке символа # и установка курсора после него\n; - Повтор поиска вперед символа, найденного при помощи f/t/F/T\n, - Повтор поиска назад символа, найденного при помощи f/t/F/T\n% - Перемещение курсора на скобку, парную той, на которой находится курсор. Парные символы можно задать при помощи команды:\n:set matchpairs\n:№ - Перемещение курсора на строку №…\n№G - Перемещение курсора на строку №…, аналогично :№…\ngg - Перемещение курсора в начало\nG - Перемещение курсора в конец\n№% - Перемещение курсора на №… процентов от начала\nH - Перемещение курсора на начало видимой части текста\nM - Перемещение курсора на середину видимой части текста\nL - Перемещение курсора на конец видимой части текста\nControl+u - На полэкрана вверх\nControl+d - На полэкрана вниз\nControl+y - На одну строку вверх. Курсор при этом не перемещается\nControl+e - На одну строку вниз. Курсор при этом не перемещается\nControl+b - На один экран минус 2 строки вверх\nControl+f - На одну экран минус 2 строки вниз\nzt - Прокрутка текста так, чтобы курсор оказался вверху экрана\nzz -Прокрутка текста так, чтобы курсор оказался в середине экрана\nzb - Прокрутка текста так, чтобы курсор оказался внизу экрана\n\n\nВ обычном режиме:\n_«_ Сдвинуть строку влево (табуляция)\n_»_ Сдвинуть строку вправо (табуляция)\n\n\nРежим выделения:\nv - Войти в режим выделения символов\nV - Войти в режим выделения строк\nControl+Shift+v - Войти в режим выделения прямоугольного блока текста\ngv - Выделяет текст, который был выделен предыдущей командой выделения\no - Перемещение курсора в области блочного выделения для изменения размера влево\nO - Перемещение курсора в области блочного выделения для изменения размера вправо\nI - Включить вставку символов в блочном выделении. После нажатия I набираются символы, а по окончании нажимаете Escape. Все набранные символы будут вставлены в каждую строку\nс - Аналогично I, но перед вставкой символов удаляет всё, что было выделено блоком\nс - Аналогично I, но перед вставкой символов удаляет всё от левого края выделения до конца строки\nu - Изменить регистр выделенных символов на нижний\nU - Изменить регистр выделенных символов на верхний\n~ - Изменить регистр выделенных символов на противоположный\nJ - Объединить все строки, находящиеся в области выделения\nr - Заменить все символы на введенный после r, например rx заменит все символы в области выделения на x\n&lt; - Сдвинуть выделенный блок влево (табуляция)\n&gt; - Сдвинуть выделенный блок вправо (табуляция)\n\n\nРабота с буфером обмена:\n**«*yy** - Скопировать строку в буфер обмена текущего выделения. Потом можно вставить скопированное в любом приложении нажатием средней кнопки (колесика) мыши\n«+yy - Скопировать строку в буфер обмена. Потом можно вставить скопированное в любом приложении нажатием Ctrl+v\n«ayy - Скопировать строку в регистр a (имена регистров соответствуют буквам латинского алфавита, возможны имена a-z)\n«Ayy - Добавить строку в регистр a\n«ap - Вставить текст из регистра a\n\n\nМетки:\nmx - Создать метку с именем x\n`x - Переместить курсор на метку x\n’x - Переместить курсор на строку с меткой x\n:marks - Просмотреть все существующие в данный момент метки\nCtrl+Shift+o - Перемещение по меткам назад\nCtrl+Shift+i - Перемещение по меткам вперед\n‘ ’ - Переместить курсор на предыдущую метку\n\n\nПоиск:\n/ - Войти в режим ввода выражения для поиска. В vim можно использовать при поиске регулярные выражения, при этом символы «.», «*», «[«, «]», «^», «%», «/», «», «?», «~», «$» являются специальными и их обязательно надо экранировать обратным слэшем («»)\nnoh - выйти из режима поиска,выключит подсветку найденого.\n? - То же, что и /, но поиск будет производиться в обратном порядке\nn - Повторить поиск вперед\nN - Повторить поиск назад\n* - Поиск слова, на котором стоит курсор, вперед, со строгим соответствием(звездочка без скобок)\n# - Поиск слова, на котором стоит курсор, назад, со строгим соответствием\ng* - Поиск слова, на котором стоит курсор, вперед, с нестрогим соответствием, то есть, если курсор на слове win, то будет найдено также слово winter\ng# - Поиск слова, на котором стоит курсор, назад, с нестрогим соответствием /выражениеоиск слова без учета регистра, независимо от настроек vim. Переключать учет регистра можно командами «:set ignorecase» и «:set noignorecase»\n&lt; - Обозначение начала слова при поиске. /\n\n&gt; - Обозначение конца слова при поиске. win — найти только /., но не winter\n/выражение/b+1 - Найти выражение и установить курсор на символ +1 от начального, то есть на второй\n/выражение/e-3 - Найти выражение и установить курсор на символ -3 от конечного\n?выражение?b+1 - То же, что и /выражение/b+1, но с поиском в обратную строну\n?выражение?e-3 - То же, что и /выражение/e-3, но с поиском в обратную строну стрелка вверх При вводе строки для поиска просмотр истории поиска выражений, начинающихся с того, что уже набрано\n\n\nДавайте подытожим список основных команд, используемых при работе с окнами в Vim.\n:split или Ctrl+w s — добавляет в сессию Vim горизонтальное окно\n:vsplit или Ctrl+w v — добавляет в сессию Vim вертикально окно\n:split filename — добавляет в сессию Vim горизонтальное окно и загружает в него filename\n:vsplit filename — добавляет в сессию Vim вертикальное окно и загружает в него filename\nCtrl+w h— переключает на левое окно, относительно текущего\nCtrl+w l — переключает на правое окно, относительно текущего\nCtrl+w j — переключает на нижнее окно, относительно текущего\nCtrl+w k — переключает на верхнее окно, относительно текущего\nCtrl+w Ctrl+w — переключает на следующее окно\nCtrl+w r — передвигает окна по часовой стрелке\nCtrl+w R — передвигает окна против часовой стрелки\nCtrl+w c — закрывает текущее окно\nCtrl-w стрелочки :) — переместиться на окно влево/вправо/вверх/вниз\nСtrl-w o — развернуть окно\nCtrl-w c — закрыть\nCtrl-w s — разделить окно по горизонтали\nCtrl-w v — тоже, только по вертикали\nCtrl+w + — увеличение размера окна по горизонтали;\nCtrl+w — — уменьшение размера окна по горизонтали;\nCtrl+w &gt; — увеличение размера окна по вертикали;\nCtrl+w &lt; — уменьшение размера окна по вертикали;\nCtrl-w ] — разделить и перейти на определение чего-то, что под курсором\nCtrl-w f — разделить и в новом окне открыть файл путь к которому находится под курсором, очень удобно делать на инклюдах\n\n\nКоманды:\n:split — разделить, если указан файл то открыть его\n:vsplit — тоже только по вертикали\n:sb[uffer**] — разделить и редактировать буффер. Важный момент: если заново открыть файл (к примеру через :split**) то буфер сбрасывается, вместе с историей отмен и положением курсора\n\n\nДавайте подытожим список команд для работы с вкладками:\nvim -p filename1 filename2 — запустит Vim и откроет (или создаст новые) файлы filename1 и filename2 в двух вкладках\n:tabnew — откроет пустую вкладку\n:tabnew filename— откроет новую вкладку и загрузит (создаст новый) в ней файл filename\ngt — переключит на следующую вкладку\ngT — переключит на предыдущую вкладку\n:tabc — закроет текущую вкладку\nИ так, буфер это некий сеанс редактирования определённого файла. \nК примеру если вы открыли **.vimrc** и в запущенном виме выполнели **:e .bashrc**, то откроется **.bashrc**. \nТем не менее буфер с **.vimrc** останется открытым и доступным для редактирования. \n\n\nВот основные команды для работы с буферами:\n:bn - следующий буфер\n:bp - предыдущий\n:ls - просмотреть открытые буферы\n:b - имя_буфера переключиться на буфер, очень удобно комбинируется с табом, к примеру пишем :b domain, жмём таб и нам подставляется открытый iis_domain.cpp\n:bd - удалить текущий буфер, правда стоит заметить, что если этот буфер единственное окно то vim закроется\n:bd - имя_буфера удалить буфер по имени\n\n\nМИНИМАЛЬНЫЕ ОСНОВЫ\nНа данный момент существует две версии редактора - vi и vim. Vim расшифровывается как Vi Improved, улучшенный vi.\nБуду писать vi, это значит, что я предполагаю использование vim.\nТекстовый редактор Vim может работать в двух режимах.\nЭто и есть его главная особенность.\nПервый режим, который используется по умолчанию при открытии редактора - это командный. В этом режиме вы можете вводить команды vi, а также использовать символьные клавиши для управления редактором.\nВторой режим - обычное редактирование текста, он работает так же как и редактирование текста в nano.\nДля переключения в командный режим используется клавиша Esc.\nДля переключения в режим редактирования - клавиша i.\nЕсли вас интересует только как в редакторе vi сохранить и выйти, листайте вниз, но если вы хотите узнать как пользоваться текстовым редактором vim, эта статья для вас.\nДело в том, что команд и сочетаний клавиш у vim очень много и запомнить их все без практики невозможно.\nДля запуска обучения наберите:\nvimtutor\n\n\nКАК ИСПОЛЬЗОВАТЬ РЕДАКТОР VIM\nСинтаксис Vim очень прост:\n$ vim опции имя_файла\nИли:\n$ vi опции имя_файла\nПростой запуск vim без указания имени файла приведет к созданию пустого файла.\nА теперь давайте рассмотрим основные опции запуска:\n• +номер - переместить курсор к указной строке после запуска.\n• +/шаблон - выполнить поиск по шаблону и переместить курсор к первому вхождению\n• “+команда” - выполнить команду после запуска программы\n• -b - двоичный режим, для редактирования исполняемых файлов.\n• -d - режим поиска различий в файлах, нужно указать несколько файлов для открытия.\n• -g - графический режим.\n• -n - не использовать автосохранение для восстановления файла при сбое.\n• -R - режим только для чтения.\n• -w - сохранить все действия в файл.\n• -x - шифровать файл при записи.\n• -C - режим совместимости с Vi.\nКруто, правда? Но это только начало. Опции ничего по сравнению с командами редактора.\n\n\nКОМАНДНЫЙ РЕЖИМ VIM\nВ командном режиме вы можете перемещаться по редактируемому тексту и выполнять действия над ним с помощью буквенных клавиш. Именно этот режим открывается по умолчанию при старте редактора. Здесь вы будете использовать краткие команды, перед которыми может устанавливаться номер, чтобы повторить команду несколько раз. Для начинающих может быть поначалу очень запутанно то, что в командном режиме символы интерпретируются как команды.\nДля перемещения используются такие команды:\n• h - на один символ влево;\n• l - на один символ вправо;\n• j - на одну строку вниз;\n• k - на одну строку вверх;\n• w - на слово вправо;\n• b - на слово влево;\n• H - перейти в низ экрана;\n• G - перейти в конец файла;\nМожете запустить редактор и поэкспериментировать, чтобы было легче понять как это работает. Если перед тем как нажать кнопку буквы нажать цифру, то эта команда будет повторена несколько раз. Например, 3j переведет курсор на три строки вверх.\nДля переключения в режим редактирования используются такие команды:\n• i - вставить текст с позиции курсора, символ под курсором будет заменен;\n• I - вставить текст в начало строки;\n• a - добавить текст начиная от позиции курсора;\n• o - вставить новую строку после этой и начать редактирование;\n• O - вставить новую строку перед этой и начать редактирование;\n• r - заменить текущий символ;\n• R - заменить несколько символов.\nК этим командам тоже применимы символы повторения. Поэкспериментируйте, можно получить интересный и не совсем ожиданий результат. Более сложны команды редактирования текста. Вы можете править текст не только в обычном режиме, но и в командном с помощью команд.\nДля этого применяются такие команды:\n• d - удалить символ;\n• dd - удалить всю строку;\n• D - удалить символы начиная от курсора и до конца строки;\n• y - копировать символ;\n• yy или Y - скопировать всю строку;\n• v - выделить текст;\nЭти команды редактора vim работают немного по-другому после нажатия одной из них ничего не произойдет. Мы еще можем задать количество символов, к которым будет применена команда и направление, с помощью кнопок перемещения курсора. Например, чтобы удалить два символа справа от курсора нажмите d3l, а чтобы удалить три строки вниз - d3j. Команды yy, dd, Y - не что иное, как сокращения.\nКроме этих команд, есть еще несколько полезных, которые мы не можем не рассмотреть:\n• p - вставить после позиции курсора;\nP - вставить перед позицией курсора;\n• u - отменить последнее действие;\n• . - повторить еще раз последнее действие;\n• U - отменить последнее действие в текущей строке;\n• /шаблон - искать вхождение;\n• %s/шаблон/заменить - заменить первое слово на второе;\n• n - продолжить поиск вперед;\n• N - продолжить поиск назад;\nС основными командами разобрались. Но у нас есть еще командная строка Vim, которая сама по себе тоже представляет огромный интерес.\n\n\nКОМАНДНАЯ СТРОКА VIM\nКомандная строка Vim запускается в командном режиме нажатием двоеточия - “:”. Здесь доступны команды для сохранения файла и выхода из редактора, настройки внешнего вида и взаимодействия с внешней оболочкой.\nРассмотрим наиболее часто используемые команды редактора vim:\n• :w - сохранить файл;\n• :q - закрыть редактор;\n• :q! - закрыть редактор без сохранения;\n• :e файл - прочитать содержимое файла в позицию курсора;\n• :r файл - вставить в содержимое файла в следующую строку;\n• :r! - выполнить команду оболочки и вставить ответ в редактор;\n• :set переменная=значение - установить значение переменной, например, tabstop=4, или set number, с помощью этой команды можно управлять многими аспектами работы vim.\n• :buffers - посмотреть открытые файлы.\nСо всеми основами разобрались, и вы теперь использование vim не будет казаться вам таким сложным. Но это еще далеко не все, этот мощный редактор может еще очень многое. Дальше мы рассмотрим несколько примеров использования vim, чтобы вам было легче справиться с новой программой.\n\n\nРЕДАКТИРОВАНИЕ ФАЙЛА В VIM\nНесмотря на то, что из всего вышесказанного можно понять как это делается рассмотрим еще раз. Чтобы открыть файл выполните: vim имя_файла Затем, если вы не хотите пока использовать возможности командного режима просто нажмите i, чтобы перейти в режим редактирования. Здесь вы можете редактировать файл так же, как и в nano. После того как завершите нажмите Esc, чтобы перейти в командный режим и наберите :wq. Записать и выйти. Все, готово.\n\n\nПОИСК И ЗАМЕНА В VIM\nДовольно часто нам нужно найти определенную последовательность в тексте.\nТекстовый редактор Vim умеет это делать.\nВо-первых, если нужно найти символ в строке, нажмите f и наберите нужный символ, курсор будет перемещен к его позиции.\nДля поиска по всему файлу используйте команду /.\nПосле нее нужно ввести слово, которое нужно найти.\nДля поиска следующего вхождения используйте n,\nдля предыдущего - N.\nДля замены будет использоваться немного другая конструкция:\n:%s/искать/заменить/g\nДвоеточие запускает командную оболочку с командой s для замены. Символ % означает что обрабатывать нужно весь файл, а g значит, что нужно обработать все найденные строки, а не только первую. Чтобы программа спрашивала перед каждой заменой можно добавить в конец строки опцию c.\n\n\nОДНОВРЕМЕННОЕ РЕДАКТИРОВАНИЕ НЕСКОЛЬКИХ ФАЙЛОВ\nЧтобы открыть несколько файлов, просто передайте их в параметры при запуске программы: vim файл1 файл2 файл3\nРедактор vim linux откроет первый файл, для переключения ко второму используйте команду :n, чтобы вернутся назад :N.\nС помощью команды :buffers вы можете посмотреть все открытые файлы, а командой :buffer 3 переключится на третий файл.\n\n\nБУФЕР ОБМЕНА VIM\nТекстовый редактор Vim имеет свой буфер обмена. Например, вам нужно скопировать в четыре строки и вставить их в другое место программы, для этого выполните такую последовательность действий:\n• Нажмите Esc, чтобы перейти в командный режим;\n• Наберите 4yy чтобы скопировать четыре строки;\n• Переместите курсор в место где нужно вставить эти строки;\n• Нажмите p для вставки.\nТакже можно использовать выделение vim, чтобы скопировать строки. Выделите текст с помощью v, а затем нажмите y, чтобы скопировать.\n\n\nКИРИЛЛИЦА В VIM\nКириллица в Vim работает превосходно. Но есть одно но, когда включена кириллица в системе, все команды vim не работают, им и не нужно работать, они же не приспособлены для кириллицы. Но переключать каждый раз раскладку, когда работаете в командном режиме тоже не очень удобно.\nоткрываем файл ~/.vimrc и добавляем туда такие строки:\nset keymap=russian-jcukenwin\nset iminsert=0\nset imsearch=0"
  },
  {
    "objectID": "posts/ffmpeg_convert_media/ffmpeg_convert_media_file.html",
    "href": "posts/ffmpeg_convert_media/ffmpeg_convert_media_file.html",
    "title": "Конвертировать медиа файлы между форматами",
    "section": "",
    "text": "Конвертировать медиа файлы\nffmpeg -i video_input.mp4 video_output.avi\nffmpeg -i video_input.webm video_output.flv\nffmpeg -i audio_input.mp3 audio_output.ogg\nffmpeg -i audio_input.wav audio_output.flac\nВы даже можете указать больше выходных файлов:\nffmpeg -i audio_input.wav audio_output_1.mp3 audio_output_2.ogg\nЭто преобразует входные файлы во все указанные форматы.\nЧтобы увидеть список всех поддерживаемых форматов, используйте:\nffmpeg -formats\nОпять же, вы можете добавить -hide_banner, чтобы опустить информацию о приложении.\nВы можете указать параметр -qscale 0 перед выходным файлом, чтобы сохранить качество видеофайла:\nffmpeg -i video_input.wav -qscale 0 video_output.mp4\nКроме того, вы можете указать кодеки, которые вы хотите использовать, добавив -c:a (для аудио) и -c:v (для видео) с последующим названием кодеков, или скопировать, если хотите использовать те же кодеки, что и оригинальный файл:\nffmpeg -i video_input.mp4 -c:v copy -c:a libvorbis video_output.avi"
  },
  {
    "objectID": "posts/ffmpeg_обрезать_кодировть_aac/ffmpeg_обрезать_кодировть_aac.html",
    "href": "posts/ffmpeg_обрезать_кодировть_aac/ffmpeg_обрезать_кодировть_aac.html",
    "title": "Нарезка кадров",
    "section": "",
    "text": "Нарезка видео с помощью FFmpeg\n\nобрезать с …+ кодер aac\nffmpeg -i ts.mp4 -ss 00:00:20 -c:a aac -b:v 15000k -b:a 320k output.mp4\nВходной файл - ts.mp4\nВремя начала - -ss (ЧЧ:ММ:СС)\nАудио кодек (aac) - -c:a aac\nБитрейт видео - -b:v 15000k\nБитрейт аудио -b:a 320k\nВыходной файл - output.mp4\nМы указали, что хотели бы, чтобы остальное было сохранено (начиная с 00:00:20) + кодек"
  },
  {
    "objectID": "posts/ffmpeg_Извлечение_аудио_из_видео\n/ffmpeg_Извлечение_аудио_из_видео\n.html",
    "href": "posts/ffmpeg_Извлечение_аудио_из_видео\n/ffmpeg_Извлечение_аудио_из_видео\n.html",
    "title": "Извлечение аудио из видео",
    "section": "",
    "text": "Извлечение аудио из видео\nЧтобы извлечь аудио из видеофайла, вы делаете простое преобразование и добавляете флаг -vn:\nffmpeg -i video.mp4 -vn audio.mp3\nОбратите внимание, что эта команда будет использовать битрейт (скорость передачи) исходного файла.\nВы можете установить его вручную, и для этого использовать -ab (audio bit rate):\nffmpeg -i video.mp4 -vn -ab 128k audio.mp3\nНекоторые распространенные битрейты: 96 КБ, 128 КБ, 192 КБ, 256 КБ, 320 КБ.\nДругими общими параметрами являются:\n-ar (частота звука: 22050, 441000, 48000), \n-ac (количество аудиоканалов), \n-f (формат аудио, хотя обычно определяется автоматически). -ab также можно заменить на -b:a. \nНапример:\nffmpeg -i video.mov -vn -ar 44100 -ac 2 -b:a 128k -f mp3 audio.mp3"
  },
  {
    "objectID": "posts/ffmpeg_Извлечение_аaudio_from_video\n/ffmpeg_Извлечение_аудио_из_видео\n.html",
    "href": "posts/ffmpeg_Извлечение_аaudio_from_video\n/ffmpeg_Извлечение_аудио_из_видео\n.html",
    "title": "Извлечение аудио из видео",
    "section": "",
    "text": "Извлечение аудио из видео\nЧтобы извлечь аудио из видеофайла, вы делаете простое преобразование и добавляете флаг -vn:\nffmpeg -i video.mp4 -vn audio.mp3\nОбратите внимание, что эта команда будет использовать битрейт (скорость передачи) исходного файла.\nВы можете установить его вручную, и для этого использовать -ab (audio bit rate):\nffmpeg -i video.mp4 -vn -ab 128k audio.mp3\nНекоторые распространенные битрейты: 96 КБ, 128 КБ, 192 КБ, 256 КБ, 320 КБ.\nДругими общими параметрами являются:\n-ar (частота звука: 22050, 441000, 48000), \n-ac (количество аудиоканалов), \n-f (формат аудио, хотя обычно определяется автоматически). -ab также можно заменить на -b:a. \nНапример:\nffmpeg -i video.mov -vn -ar 44100 -ac 2 -b:a 128k -f mp3 audio.mp3"
  },
  {
    "objectID": "posts/ffmpeg_extract_audio_from_video/ffmpeg_Извлечение_аудио_из_видео\n.html",
    "href": "posts/ffmpeg_extract_audio_from_video/ffmpeg_Извлечение_аудио_из_видео\n.html",
    "title": "Извлечение аудио из видео",
    "section": "",
    "text": "Извлечение аудио из видео\nЧтобы извлечь аудио из видеофайла, вы делаете простое преобразование и добавляете флаг -vn:\nffmpeg -i video.mp4 -vn audio.mp3\nОбратите внимание, что эта команда будет использовать битрейт (скорость передачи) исходного файла.\nВы можете установить его вручную, и для этого использовать -ab (audio bit rate):\nffmpeg -i video.mp4 -vn -ab 128k audio.mp3\nНекоторые распространенные битрейты: 96 КБ, 128 КБ, 192 КБ, 256 КБ, 320 КБ.\nДругими общими параметрами являются:\n-ar (частота звука: 22050, 441000, 48000), \n-ac (количество аудиоканалов), \n-f (формат аудио, хотя обычно определяется автоматически). -ab также можно заменить на -b:a. \nНапример:\nffmpeg -i video.mov -vn -ar 44100 -ac 2 -b:a 128k -f mp3 audio.mp3"
  },
  {
    "objectID": "posts/ffmpeg_audio_from_video/extract.html",
    "href": "posts/ffmpeg_audio_from_video/extract.html",
    "title": "Извлечение аудио из видео",
    "section": "",
    "text": "Извлечение аудио из видео\nЧтобы извлечь аудио из видеофайла, вы делаете простое преобразование и добавляете флаг -vn:\nffmpeg -i video.mp4 -vn audio.mp3\nОбратите внимание, что эта команда будет использовать битрейт (скорость передачи) исходного файла.\nВы можете установить его вручную, и для этого использовать -ab (audio bit rate):\nffmpeg -i video.mp4 -vn -ab 128k audio.mp3\nНекоторые распространенные битрейты: 96 КБ, 128 КБ, 192 КБ, 256 КБ, 320 КБ.\nДругими общими параметрами являются:\n-ar (частота звука: 22050, 441000, 48000), \n-ac (количество аудиоканалов), \n-f (формат аудио, хотя обычно определяется автоматически). -ab также можно заменить на -b:a. \nНапример:\nffmpeg -i video.mov -vn -ar 44100 -ac 2 -b:a 128k -f mp3 audio.mp3"
  },
  {
    "objectID": "posts/ImageMagick/ImageMagick.html",
    "href": "posts/ImageMagick/ImageMagick.html",
    "title": "ImageMagick.Обработка изображений.",
    "section": "",
    "text": "ImageMagick.Обработка изображений.\n\nИзменить размер изображения\nconvert img.jpg -resize 100×150 img1.jpg\n\n\nСжать изображение по ширине до 100px\nПри этом высота будет сжата пропорционально.\nconvert img.jpg -resize 100 img1.jpg\n\n\nСжать изображение по высоте до 150px\nАналогично предыдущему.\nconvert img.jpg -resize ×150 img1.jpg\n\n\nИзменение размера изображения без сохранения соотношения сторон\n\n-resize &lt; MMM x NNN! &gt;\n\nconvert img.jpg -resize 100×150! img1.jpg\n\nИзменение размера изображения в процентах\n\n-resize &lt; MMM% &gt; — изменение размера изображения в %(процентах)\n\nconvert img.jpg -resize 20% img1.jpg\n\n\n\nПоворот изображения\nДля того что бы повернуть изображение существует параметр -rotate, где значение указывается в градусах:\nconvert img.jpg -rotate 20 img1.jpg\n\n\nКонвертирование в другой формат\nmogrify -format tif \\*.png\nПереведет все .png-изображения в tif\n\n\nКачество *.jpg\nconvert img.jpg -quality 75 img2.jpg\n\n\nПрактическое применение некоторых возможностей пакета\nОпишем некоторые приёмы обработки изображений при помощи ImageMagick.\n\n\nСоздание анимации\nanimate -delay значение -loop 0 \\*\nЭта команда создаёт из всех файлов в данной папке анимацию. После выполнения результат работы будет показан в окне.\nЧтобы сохранить анимацию, раскройте меню, нажав левой кнопкой мыши в области окна вывода анимации, затем выберете Animate &gt; Save и укажите имя файла и выберите желаемый формат.\nЗначение после аргумента -delay задаёт паузы между кадрами сотых секундах. Например, -delay 100 означает секундную задержку перед показом очередного кадра анимации.\nЗначение аргумента -loop указывает на то, сколько раз нужно повторить сначала анимацию. Значение -loop 0 задаёт неограниченное количество циклов повторения.\n\n\nРазличия между двумя изображениями\ncompare изображение1 изображение2 имя_результирующего_изображения\nИзображения должны быть одинакового разрешения. Результатом работы программы, грубо говоря, станет изображение, где будет выделены цветом пиксели, которые различны в двух заданных изображениях.\n\n\nНаложение одного изображения на другое\ncomposite изображение1 изображение2 имя_результирующего_изображения\nНакладывает изображение1 на изображение2, результатом работы станет изображение имя_результирующего_изображения.\n\n\nВывод изображения на экран\ndisplay имя_изображения\nВыводит указанное изображение на экран.\nПри нажатии на изображение откроется меню ImageMagick, где можно проводить операции с изображением как в обычном графическом редакторе, так что ImageMagick поддерживает не только текстовый интерфейс.\n\n\nИнформация об изображении\nidentify изображение1 \\[изображение 2 ... \\]\nПозволяет узнать тип, разрешение, глубину цвета, размер и другие параметры указанных изображений.\n\n\nСоздание скриншота\nimport имя_результирующего_изображения\nПри вызове программы необходимо мышкой указать прямоугольную область экрана. Результат будет сохранён в имя_результирующего_изображения.\n\n\nИзменение разрешения изображения\nconvert -resize ШИРИНАxВЫСОТА изображение изменённое_изображение\nЯвно задаёт новое разрешение. Пропорциональность сохраняется, даже если введённые значения непропорциональны изначальному разрешению.\n\n\nИзменение разрешения в процентах\nconvert -resize количество\\_% изображение изменённое_изображение\n\n\nИзменения разрешения относительно старого разрешения.\nПример использования:\nconvert -resize 50% \\*.png resized.png\nУменьшает разрешение всех изображений с расширением png в папке в два раза. Изменённые изображения будут называться resized-порядковый_номер.\n\n\nКадрирование изображения\nconvert \\*.jpg -crop ШИРИНАxВЫСОТА+0+0 output_изображение.jpg\nВырезает прямоугольник размера ШИРИНАxВЫСОТА из изображения, начиная с крайнего левого угла. Чтобы сместить точку начала кадрирования нужно задавать координаты точки начала, например 100x100+50+50 — вырежет область размером 100x100 начиная с точки на изображения с координатами x=50 y=50 (эти координаты отсчитываются от крайнего левого угла).\n\n\nИзменить глубину цвета\nconvert \\*.jpg -depth значение_глубины изображение имя_результирующего_изображения\n\n\nСклейка изображений в единое\nconvert \\* +append имя_результирующего_изображения\nИз всех файлов в папке создаёт единое изображение, в котором содержаться все изображения из папки в ряд (опция +append означает добавить изображение в ряд с права).\n\n\nДобавление цветной рамки вокруг изображения\nconvert \\*.jpg -bordercolor имя_цвета -border размер_бордюра изображение имя_результирующего_изображения\nПример:\nconvert \\*.jpg -bordercolor green -border 3x3\n\nПоворот изображения\nconvert \\*.jpg -rotate +/-градус изображение имя_результирующего_изображения\n“+” указывает на направление по часовой стрелки, а “-” против часовой. “&gt;” разрешает поворачивать только если ширина больше высоты, а “&lt;” наоборот.\nПример:\nconvert -rotate +90"
  },
  {
    "objectID": "posts/ImageMagick_Основные_команды/ImageMagick_Основные_команды.html",
    "href": "posts/ImageMagick_Основные_команды/ImageMagick_Основные_команды.html",
    "title": "ImageMagick.Обработка изображений.",
    "section": "",
    "text": "ImageMagick — набор программного обеспечения для редактирования и обработки цифровых изображений. Он включает утилиты командной строки, которые позволяют создавать, редактировать, компоновать или преобразовывать растровые изображения.\n\nОсновные команды\nНекоторые ключевые команды ImageMagick:\nconvert — преобразование изображений из одного формата в другой;\nКоманда convert устарела, используйте “magick” вместо “convert” или “magick convert”;\nmogrify — преобразование с заменой исходного файла;\nmontage — монтаж изображений;\ncompose — совмещение (композиция) изображений;\nidentify — получение информации об изображении.\n\n\nПримеры команд\nПример команды для преобразования JPG-изображения в формат PNG:\nconvert 1.jpg 1.png.\nЕщё один пример:\nconvert -resize 50% 1.jpg 1_1.jpg — уменьшение размера изображения на 50%.\nДля получения информации об изображении используется команда:\nidentify -ping 1.jpg\nдля подробных данных:\nidentify -verbose 1.jpg."
  },
  {
    "objectID": "posts/imagemagick_convert_new/imagemagick_convert_new.html",
    "href": "posts/imagemagick_convert_new/imagemagick_convert_new.html",
    "title": "ImageMagick. New!!!",
    "section": "",
    "text": "!!! ЧИТАТЬ ОБЯЗАТЕЛЬНО !!!\nКоманда convert устарела в Img7(ImageMagick7), используйте “magick” вместо “convert” или “magick convert”.\nmagick *.webp *.jpg\nВ дистрибутивах, в репозиториях которых есть ImageMagick 7.*, обе утилиты доступны после установки этого пакета:\nmagick\nconvert\nИ вы можете использовать любую из этих команд для преобразования изображений и выполнения других действий.\nНо на самом деле команда « convert » — это всего лишь символическая ссылка на « magick ».\nПри этом синтаксис и опции этих команд одинаковы, поэтому вы можете использовать « convert » или « magik » как взаимозаменяемые команды для конвертации изображений, хотя на самом деле будет вызвана команда « magik », просто потому что « convert » — это символическая ссылка на нее.\nСледующие команды также являются символическими ссылками на команду magick:\nanimate\ncompare\ncomposite\nconjure\nconvert\ndisplay\nidentify\nimport\nmogrify\nmontage\nstream\nВсе эти команды теперь отсутствуют как отдельные программы, и их вызов запустит magick . По этой причине вы можете столкнуться с проблемой, что хотя эти утилиты присутствуют в системе, при попытке их использования будут возникать ошибки, связанные с неправильным синтаксисом или параметрами программы.\nОднако вы все равно можете вызвать устаревшую утилиту, пример вызова утилиты logo :\nmagick logo: logo.png\nВ дистрибутивах с ImageMagick 6.* для конвертации изображений доступна только программа « convert »"
  },
  {
    "objectID": "posts/imagemagick_quality_thumbnail/imagemagick_quality_thumbnail.html",
    "href": "posts/imagemagick_quality_thumbnail/imagemagick_quality_thumbnail.html",
    "title": "Основные опции ImageMagick для сжатия и ресайза",
    "section": "",
    "text": "JPG. Основные опции ImageMagick для сжатия и ресайза\nВажно понимать, что нет «лучших» настроек. Применение одинаковых настроек ко всем изображениям, не даст лучших результатов. Некоторые изображения будут выглядеть размытыми, или наоборот, слишком резкими. Поэтому нужно выбрать «средние» параметры, которые вам подойдут.\nПримеры использования параметра -quality:\nconvert img.jpg -quality 80 img1.jpg\nПримеры использования параметра -thumbnail:\nРесайз по ширине 100px, с сохранением соотношения сторон (высота изменится пропорционально):\nconvert img.jpg -thumbnail 100x img1.jpg\nРесайз по высоте 150px, с сохранением соотношения сторон (ширина изменится пропорционально).\nconvert img.jpg -thumbnail x150 img1.jpg\nРесайз без сохранения соотношения сторон:\nconvert img.jpg -thumbnail 100x150! img1.jpg\nРесайз в % (процентах):\nconvert img.jpg -thumbnail 20% img1.jpg \n-quality 80 — уровень сжатия (80 приблизительно равен 60 в Adobe Photoshop)\n-strip — удаление всех метаданных (exif, цветовой профиль и т.п.).\n-resize — изменяет размер изображения в пикселях.\n-thumbnail — опция похожая на -resize. Помимо реcайза, удаляет также и метаданные изображения. Говорят, что работает быстрее и качественнее, чем -resize\n\n-filter Lanczos — фильтр Ланцоша.\n-gaussian-blur 0.05 — размытие по Гауссу.\nПараметры: Радиус × Сигма в пикселях. Сигма — это стандартное отклонение от нормального распределения Гаусса. Небольшое размытие уменьшает размер, но снижает качество при масштабировании изображения.\n-sampling-factor 4:2:0 — цветовая субдискретизация.\nЗначение 4:2:0 уменьшает разрешение канала цветности до половины. Применяется только если параметр -quality меньше чем 90. Параметр -sampling-factor определяет коэффициенты выборки, которые будут использоваться кодером JPEG, для понижающей дискретизации цветности. Если этот параметр опущен, библиотека JPEG будет использовать собственные значения по умолчанию. Рекомендуется использовать его вместе с параметром -define jpeg:dct-method=float, что дает небольшое улучшение качества, без увеличения размера файла, поскольку использует более точное дискретное косинус-преобразование с плавающей запятой.\n-unsharp 0x3+1+0 — придает ощущение большей четкости изображения.\nЗначения: Радиус× Сигма+усиление+порог.\nРадиус — радиус гауссова размытия в пикселях, не считая центральный пиксель (по умолчанию 0). Для приемлемых результатов радиус должен быть больше сигмы. Если он не задан или установлен на ноль, ImageMagick рассчитает максимально возможный радиус, который даст приемлемые результаты для распределения Гаусса.\nСигма — стандартное отклонение гауссова размытия в пикселях (по умолчанию 1.0). Является важным аргументом и определяет фактическое количество размытия, которое будет иметь место.\nУсиление — величина разницы между оригинальным и размытым изображением, которое добавляется обратно в оригинал (по умолчанию 1.0).\nПорог — величина количественной разницы между изображениями (по умолчанию 0,05).\n- colorspace RGB — цветовое пространство RGB.\n-interlace Plane — используется если нужен прогрессивный JPEG."
  },
  {
    "objectID": "posts/imagemagick_border_black-white_PDF/imagemagick_рамки_черно-белое_негатив_PDF.html",
    "href": "posts/imagemagick_border_black-white_PDF/imagemagick_рамки_черно-белое_негатив_PDF.html",
    "title": "Добавление рамки, черно-белое и негатив, серое, PDF-альбом",
    "section": "",
    "text": "Хотите поместить картинку в рамку и думаете, как и каким редактором это сделать? Больше ничего искать не нужно:\nconvert -bordercolor red -border 10 1.jpg 1_3.png\nЦвет, в данном случае «red» (красный), указывается на английском. Цифра, в рассматриваемом примере «10», определяет толщину рамки. Результатом применения команды стал графический файл «1_3.png».\n\nКак сделать из картинки негатив? Очень просто:\nconvert -negate 1.jpg 1_4.jpg\n\nНужно из цветного изображения сделать черно-белое (хотя правильнее было бы сказать — монохромное). И этот полезный эффект достигается всего одной командой:\nconvert 1.jpg -monochrome 1_5.jpg\n\nИзображения в оттенках серого:\nconvert photo.jpg -colorspace Gray out.jpg\nor\nconvert photo.jpg -type Grayscale out.jpg\nУвеличение контрастности:\nconvert photo.jpg -contrast-stretch 4x4 colorspace Gray out.jpg\nСбалансированный результат с хорошими текстурами:\nconvert photo.jpg -linear-stretch 1x1 -colorspace Rec709Luma out.jpg\n\nВам было бы удобнее сделать из всех картинок каталога виртуальный фотоальбом в формате PDF и потом смотреть его на своем телефоне или показывать друзьям? И для этого вам не понадобятся никакие сложные инструменты, требующие длительного изучения.\nconvert *.* 1.pdf\nor \nconvert * 1.pdf\nВ том же каталоге, в котором располагается ваша коллекция изображений, появится файл формата PDF с полной подборкой всех изображений папки. Когда вы будете применять данную команду, сначала переместите в одну директорию весь контент, который вы собираетесь поместить в создаваемый вами PDF-альбом."
  },
  {
    "objectID": "posts/ImageMagick_Создание_фотоальбома/ImageMagick_Создание_фотоальбома.html",
    "href": "posts/ImageMagick_Создание_фотоальбома/ImageMagick_Создание_фотоальбома.html",
    "title": "Создание фотоальбома",
    "section": "",
    "text": "Вам было бы удобнее сделать из всех картинок каталога виртуальный фотоальбом в формате PDF? И для этого вам не понадобятся никакие сложные инструменты:\nconvert *.* 1.pdf\nmagick *.* 1.pdf\nor\nconvert * 1.pdf\nmagick * 1.pdf\nВ том же каталоге, в котором располагается ваша коллекция изображений, появится файл формата PDF с полной подборкой всех изображений папки.\n\nP.S\nЕсли вы хотите вполовину уменьшить размер картинки, то введите команду\nconvert 1.jpg -resize 50% 1_1.jpg\nПри этом исходное изображение также будет сохранено.\nЕсли вы хотите преобразовать JPG-изображение в формат PNG, введите и примените команду:\nconvert 1.jpg 1.png\nПолучить информацию об изображении можно с помощью команды:\nidentify -ping 1.jpg\nИтогом ее применения станут краткие данные о картинке. Узнать о ней больше вам поможет уже другая команда:\nidentify -verbose 1.jpg\nЗдесь вы увидите много подробностей, которые могут быть интересны только профессионалу или тому, кто увлекается обработкой графики.\nПолучить полный перечень всех используемых в изображении цветов помогает команда:\nidentify -list color 1.jpg\nХотите поместить картинку в рамку и думаете, как и каким редактором это сделать? Больше ничего искать не нужно:\nconvert -bordercolor red -border 10 1.jpg 1_3.png\nЦвет, в данном случае «red» (красный), указывается на английском. Цифра, в рассматриваемом примере «10», определяет толщину рамки. Результатом применения команды стал графический файл «1_3.png».\nКак сделать из картинки негатив?\nОчень просто:\nconvert -negate 1.jpg 1_4.jpg\nНужно из цветного изображения сделать черно-белое (хотя правильнее было бы сказать — монохромное).\nИ этот полезный эффект достигается всего одной командой:\nconvert 1.jpg -monochrome 1_5.jpg"
  },
  {
    "objectID": "posts/imagemagick_identify_convert_mogrify_display/imagemagick_identify_convert_mogrify_display.html",
    "href": "posts/imagemagick_identify_convert_mogrify_display/imagemagick_identify_convert_mogrify_display.html",
    "title": "ImageMagick - утилиты входящие в состав",
    "section": "",
    "text": "mogrify,convert,identify - утилиты входящие в состав imagemagick.\n\nmogrify - произвести действия над самим изображением\nconvert - произвести действия над изображением и сохранить в другой файл\ndisplay - вывести изображение на экран\nanimate - вывести анимированное изображение на экран\n\n\nКоманда convert требует указания выходного файла, а mogrify производит операции над самим файлом.\nОни используются для применения преобразований к файлам изображений. Они понимают одинаковые ключи.\n\n\nmogrify\nДля изменения размера изображения, размытия, обрезки, удаления пятен, дизеринга, рисования, переворота, объединения, повторной выборки и многого другого.\nЭтот инструмент похож на magick , за исключением того, что исходный файл изображения перезаписывается (если вы не измените суффикс файла с помощью опции -format ) любыми запрошенными вами изменениями.\nДля начала давайте уменьшим размер:\nmagick mogrify -resize 50% rose.jpg\nИзменить размер всех изображений JPEG в папке до максимального размера 256x256 с помощью этой команды:\nmagick mogrify -resize 256x256 *.jpg\nКонвертируем все наши изображения PNG в папке в формат JPEG:\nmagick mogrify -format jpg *.png\n\n\n\ndisplay\nДля отображения изображения или последовательности изображений на любом сервере X.\ndisplay 1.jpg\nИ указанный файл появится перед вами в окне может быть и не слишком стильного, но весьма функционального графического редактора с достаточно большим набором функций по редактированию изображений и солидной подборкой эффектов. Этот программный инструмент будет очень полезен тем, кто не располагает мощным компьютером, но хотел бы обрабатывать графику.\n\n\nНаложить текстуру сланца на корневое окно, используйте:\nmagick display -size 1280x1024 -window root slate.png \n\n\nОтобразить визуальный каталог всех ваших изображений JPEG, используйте:\nmagick display 'vid:*.jpg' \nПо умолчанию использует разрешение экрана X. Чтобы отобразить векторные форматы в предполагаемом размере, переопределите разрешение по умолчанию:\nmagick display -density 72 drawing.svg \n\n\n\nconvert\nДля конвертации между форматами изображений, а также для изменения размера изображения, размытия, обрезки, удаления пятен, дизеринга, рисования, переворота, объединения, повторной выборки и многого другого.\nЕсли вы хотите вполовину уменьшить размер картинки, то введите команду\nconvert 1.jpg -resize 50% 1_1.jpg\nВ данном случае «1.jpg» — имя исходного файла, а «1_1.jpg» — итогового. У вас могут быть другие названия и расширения. В папке появится новая картинка, разрешение которой на 50% меньше, чем у изначальной.\nЕсли вы хотите преобразовать JPG-изображение в формат PNG, введите и примените команду:\nconvert 1.jpg 1.png\nВ этом же каталоге появится картинка в формате PNG. Таким же образом производится преобразование из PNG в JPG, только необходимо каждый раз указывать соответствующие имена и расширения файлов.\nКомбинировать несколько операций обработки изображений для получения сложных результатов:\nmagick -size 320x85 canvas:none -font Bookman-DemiItalic -pointsize 72 \\\n  -draw \"text 25,60 \\'Magick\\'\" -channel RGBA -blur 0x6 -fill darkred -stroke magenta \\\n  -draw \"text 20,55 \\'Magick\\'\" fuzzy-magick.png\nИзменяем размер изображения с улучшением качества:\nmagick input.png -colorspace RGB +sigmoidal-contrast 11.6933 \\\n  -define filter:filter=Sinc -define filter:window=Jinc -define filter:lobes=3 \\\n  -resize 400% -sigmoidal-contrast 11.6933 -colorspace sRGB output.png');\n\n\n\nidentify\nОписывает формат и характеристики одного или нескольких файлов изображений. Она также сообщает, является ли изображение неполным или поврежденным. Возвращаемая информация включает номер изображения, имя файла, ширину и высоту изображения, является ли изображение цветным или нет, количество цветов в изображении, количество байтов в изображении, формат изображения (JPEG, PNM и т. д.) и, наконец, количество секунд, которое потребовалось для чтения и обработки изображения. Многие другие атрибуты доступны с параметром verbose.\nПолучить информацию об изображении можно с помощью команды:\nidentify -ping 1.jpg\nmagick identify 1.jpg\nИтогом ее применения станут краткие данные о картинке. Узнать о ней больше вам поможет уже другая команда:\nidentify -verbose 1.jpg\nmagick identify -verbose 1.jpg\nЗдесь вы увидите много подробностей, которые могут быть интересны только профессионалу или тому, кто увлекается обработкой графики.\n\nПолучить полный перечень всех используемых в изображении цветов помогает команда:\nidentify -list color 1.jpg"
  },
  {
    "objectID": "posts/vim_clipboard/vim_clipboard.html",
    "href": "posts/vim_clipboard/vim_clipboard.html",
    "title": "vim copy/paste",
    "section": "",
    "text": "Чтобы узнать, установлены ли функции копирования в Vim, нужно проверить поддержку буфера обмена:\nВыполнить команду:\nvim --version | grep clipboard\nЕсли появится строка «+clipboard», то Vim поддерживает буфер обмена.\nЕсли будет выведено «-clipboard», то необходимо установить версию Vim с поддержкой буфера обмена (например, vim-gtk, vim-gnome или vim-athena).\nОбратите внимание:\nвам нужно установить пакет vim-gtk (по крайней мере, в Debian), чтобы получить vim, скомпилированный с +xterm_clipboard\nsudo apt-get install vim-gtk\nВы можете вставить текст в vim с помощью сочетания клавиш gnome-terminal для вставки.\nПоместите файл в режим вставки и используйте:\nCtrl+Shift+v.\nНе забудьте заранее:\n :set paste\n\nКомандный режим\nESC\n:set paste \nПресс i\nSHIFT + Insert (с текстом, скопированным в ваш буфер обмена)\n\nESC\n:set nopaste\nПреса i\nВы вставили текст и можете снова печатать.\n\n\nКопирование в буфер с помощью терминала\nВы можете скопировать содержимое файла в буфер непосредственно из терминала:\ncat filename.txt | xclip -selection clipboard\n\n\nВставка содержимого буфера с помощью терминала\nЧтобы вставить содержимое буфера в файл, вы можете использовать:\nxclip -selection clipboard -o &gt; filename.txt"
  },
  {
    "objectID": "posts/vim+copy+paste/vim+copy+paste.html",
    "href": "posts/vim+copy+paste/vim+copy+paste.html",
    "title": "copy/paste from/to vim",
    "section": "",
    "text": "Это тоже может очень пригодится:\nИз внешнего документа скопировать текст:\nctrl+c\nВставить в vim: \nctrl+shift+v\nor \nshift+insert - (предпочтительнее)\nиз vim копировать в др.документ - shift+выделить текст,\nвставить в др.документе - нажать среднюю кнопку мыши или ctrl+v\nРаботает в Ubuntu 20,Slackware 15 - точно!\nБудут нужны установленные xclip,xsel\n\n\nКопирование в буфер с помощью терминала\nВы можете скопировать содержимое файла в буфер непосредственно из терминала:\ncat filename.txt | xclip -selection clipboard\n\n\nВставка содержимого буфера с помощью терминала\nЧтобы вставить содержимое буфера в файл, вы можете использовать:\nxclip -selection clipboard -o &gt; filename.txt"
  }
]